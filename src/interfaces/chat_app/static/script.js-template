const chatInput = document.querySelector("#chat-input");
const sendButton = document.querySelector("#send-btn");
const chatContainer = document.querySelector(".chat-container");
const themeButton = document.querySelector("#theme-btn");
const deleteButton = document.querySelector("#delete-btn");
const refreshButton = document.querySelector("#refresh-btn");
const popupForm = document.getElementById("popup-form");
const additionalThoughtsInput = document.getElementById("dislike-additional-thoughts");
const submitButton = document.getElementById("dislike-submit-button");
const closeButton = document.getElementById("dislike-close-button");
const correct_checkbox= document.getElementById("correct_checkbox");
const helpful_checkbox = document.getElementById("helpful_checkbox");
const appropriate_checkbox = document.getElementById("appropriate_checkbox");
const configDropdown = document.getElementById("config-dropdown");
const newChatButton = document.getElementById("new-chat-btn");
const conversationsList = document.getElementById("conversations-list");
const toggleSidebarButton = document.getElementById("toggle-sidebar-btn");

popupForm.style.display = "none";

// DEFINITIONS
let DEFAULT_TIMEOUT_SECS = 300
let userText = null;
let conversation_id = null;
let conversation = []
let num_responses_since_last_rating = 0;
let last_response_is_feedback_request = false;
let STREAM_CHAT_ENABLED = Boolean(window.A2RCHI_STREAMING_ENABLED);

async function fetchWithTimeout(resource, options = {}) {
    // extracts `timeout` field from options dict;
    // will default to DEFAULT_TIMEOUT_SECS if no field is present
    const { timeout = DEFAULT_TIMEOUT_SECS * 1000 } = options;
    console.log(`Sending request to ${resource} with timeout: ${timeout} ms`);

    const controller = new AbortController();
    const id = setTimeout(() => {
        console.error("Fetch timed out! Aborting request...");
        controller.abort();
    }, timeout);

    try {
        const response = await fetch(resource, { ...options, signal: controller.signal });
        console.log("API response received");
        return response;
    } catch (error) {
        console.error("Fetch error:", error);
        throw error;
    } finally {
        clearTimeout(id);
    }
}

async function populateDropdown() {

    const API_URL = "/api/get_configs"

    try {
        const response = await (await fetch(API_URL)).json();

        if (response.error) {
            console.error("API Error fetching configs",response.error);
            return;
        }

        // Clear any existing options
        configDropdown.innerHTML = '';

        // Populate the dropdown with options from the API response
        response.options.forEach(optionText => {
            const option = document.createElement("option");
            option.textContent = optionText;
            option.value = optionText;
            configDropdown.appendChild(option);
        });
    }catch (error) {
        console.error("Failed to fetch dropdown options:", error);
    }

}

async function loadConversations() {
    const API_URL = "/api/list_conversations?limit=100";
    
    try {
        const response = await (await fetch(API_URL)).json();
        
        if (response.error) {
            console.error("API Error fetching conversations", response.error);
            conversationsList.innerHTML = '<div class="loading-conversations">Error loading conversations</div>';
            return;
        }
        
        // clear the list
        conversationsList.innerHTML = '';
        
        // fill with conversations
        if (response.conversations.length === 0) {
            conversationsList.innerHTML = '<div class="loading-conversations">No conversations yet</div>';
            return;
        }
        
        response.conversations.forEach(conv => {
            const convElement = document.createElement("div");
            convElement.classList.add("conversation-item");
            convElement.dataset.conversationId = conv.conversation_id;
            
            // Mark active conversation meaning user's working conversation_id space
            if (conv.conversation_id === conversation_id) {
                convElement.classList.add("active");
            }
            
            const date = new Date(conv.last_message_at);
            const now = new Date();
            const diffDays = Math.floor((now - date) / (1000 * 60 * 60 * 24));
            let dateStr;
            if (diffDays === 0) {
                dateStr = "Today";
            } else if (diffDays === 1) {
                dateStr = "Yesterday";
            } else if (diffDays < 7) {
                dateStr = `${diffDays} days ago`;
            } else {
                dateStr = date.toLocaleDateString();
            }
            
            convElement.innerHTML = `
                <div class="conversation-item-title">${conv.title}</div>
                <div class="conversation-item-date">${dateStr}</div>
            `;
            
            convElement.addEventListener("click", () => loadConversation(conv.conversation_id));
            conversationsList.appendChild(convElement);
        });
        
    } catch (error) {
        console.error("Failed to load conversations:", error);
        conversationsList.innerHTML = '<div class="loading-conversations">Error loading conversations</div>';
    }
}

async function loadConversation(convId) {
    const API_URL = "/api/load_conversation";
    
    try {
        const response = await (await fetch(API_URL, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({ conversation_id: convId }),
        })).json();
        
        if (response.error) {
            console.error("Error loading conversation:", response.error);
            return;
        }
        
        // clear current chat & conversation state & container
        conversation = [];
        conversation_id = convId;
        num_responses_since_last_rating = 0;        
        chatContainer.innerHTML = '';
        
        // message format
        response.messages.forEach(msg => {
            const className = msg.sender === "User" ? "outgoing" : "incoming";
            const html = className === "outgoing" 
                ? `<div class="chat-content">
                        <div class="chat-details">
                            <img src="/static/images/user.svg" alt="user-img">
                            <p>${msg.content}</p>
                        </div>
                    </div>`
                : `<div class="chat-content">
                        <div class="chat-details">
                            <img src="/static/images/a2rchi.png" alt="chatbot-img">
                            <div>${msg.content}</div>
                        </div>
                        <div class="button-container">
                            <button onclick="likeResponse(this)" class="material-button">
                                <img src="/static/images/thumbs_up.png" alt="Like" width="30" height="30">
                            </button>
                            <button onclick="dislikeResponse(this)" class="material-button">
                                <img src="/static/images/thumbs_down.png" alt="Dislike" width="30" height="30">
                            </button>
                        </div>
                    </div>`;
            
            const chatDiv = createChatElement(html, className);
            chatContainer.appendChild(chatDiv);
            conversation.push([msg.sender, msg.content]);
        });
        
        // show latest history first
        chatContainer.scrollTo(0, chatContainer.scrollHeight);
        
        // update sidebar to remark active conversation
        loadConversations();
        
    } catch (error) {
        console.error("Failed to execute loadConversation:", error);
    }
}

function startNewConversation() {
    // reset conversation state
    conversation = [];
    conversation_id = null;
    num_responses_since_last_rating = 0;
    
    // clear localStorage and show default welcome text
    localStorage.removeItem("all-chats");
    const defaultText = `<div class="default-text">
                            <h1>A2rchi</h1>
                            <p>Start a conversation and explore the power of A2rchi, specially trained on XX-TRAINED_ON-XX.<br> 
                            Your chat history will be displayed here. <br> <br>
                            Remember, the more context you provide in your question, the better A2rchi will be able to answer your question! <br> <br>
                            By using this website, you agree to the <a href="/terms">terms and conditions</a>.</p>
                        </div>`;
    chatContainer.innerHTML = defaultText;
    chatContainer.scrollTo(0, chatContainer.scrollHeight);
    
    // update sidebar to deselect previous active conversation
    loadConversations();
}

const loadDataFromLocalstorage = () => {
    // Load saved chats and theme from local storage and apply/add on the page
    const themeColor = localStorage.getItem("themeColor");

    document.body.classList.toggle("light-mode", themeColor === "light_mode");
    themeButton.innerText = document.body.classList.contains("light-mode") ? "dark_mode" : "light_mode";

    const defaultText = `<div class="default-text">
                            <h1>A2rchi</h1>
                            <p>Start a conversation and explore the power of A2rchi, specially trained on XX-TRAINED_ON-XX.<br> 
                            Your chat history will be displayed here. <br> <br>
                            Remember, the more context you provide in your question, the better A2rchi will be able to answer your question! <br> <br>
                            By using this website, you agree to the <a href="/terms">terms and conditions</a>.</p>
                        </div>`

    chatContainer.innerHTML = localStorage.getItem("all-chats") || defaultText;
    chatContainer.scrollTo(0, chatContainer.scrollHeight); // Scroll to bottom of the chat container
}

const createChatElement = (content, className) => {
    // Create new div and apply chat, specified class and set html content of div
    const chatDiv = document.createElement("div");
    chatDiv.classList.add("chat", className);
    chatDiv.innerHTML = content;
    return chatDiv; // Return the created chat div
}

const refreshChat = async () => {
    // if the conversation is empty; this is a no-op
    if (conversation.length == 0) {
        return;
    }

    // remove message to be regenerated from conversation
    conversation.pop();
    chatContainer.removeChild(chatContainer.lastChild);

    // if the last response generated a feedback request, make sure to remove it here as well
    console.log(last_response_is_feedback_request)
    if (last_response_is_feedback_request) {
        console.log("remove again")
        chatContainer.removeChild(chatContainer.lastChild);
    }

    // generate new response
    showTypingAnimation(isRefresh=true);
}

const fetchChatResponse = async (incomingChatDiv, isRefresh=false) => {
    const API_URL = "/api/get_chat_response";
    const pElement = document.createElement("div");
    const configName = configDropdown.value;

    const requestOptions = {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify({
            last_message: conversation.slice(-1),
            conversation_id: conversation_id,
            config_name: configName,
            is_refresh: isRefresh,
            client_sent_msg_ts: Date.now(),
            client_timeout: DEFAULT_TIMEOUT_SECS * 1000
        }),
        timeout: DEFAULT_TIMEOUT_SECS * 1000
    };

    try {
        const response = await (await fetchWithTimeout(API_URL, requestOptions)).json();
        console.log("Full API Response:", response);

        if (response.error) {
            console.error("API Returned an Error:", response.error);
            throw new Error(response.error);
        }

        console.log("Checking response.response:", response.response);

        try {
            pElement.innerHTML = response.response;
        } catch (error) {
            console.error("Error setting innerHTML:", error);
            throw error;
        }

        if (response.a2rchi_msg_id) {
            pElement.setAttribute('id', response.a2rchi_msg_id.toString());
        }
        pElement.classList.add("default-text");
        conversation.push(["A2rchi", response.response]);
        conversation_id = response.conversation_id;
        last_response_is_feedback_request = false;
    } catch (error) {
        console.error("Fetch Error:", error);
        pElement.classList.add("error");
        pElement.textContent = "Oops! Something went wrong while retrieving the response. Please try again.";
    }

    incomingChatDiv.querySelector(".typing-animation")?.remove();
    incomingChatDiv.querySelector("#loading-text")?.remove();
    incomingChatDiv.querySelector(".chat-details").appendChild(pElement);
    localStorage.setItem("all-chats", chatContainer.innerHTML);
    chatContainer.scrollTo(0, chatContainer.scrollHeight);

    setTimeout(() => loadConversations(), 500);
    setTimeout(showFeedbackRequest, 500);
};

const streamChatResponse = async (incomingChatDiv, isRefresh=false) => {
    const API_URL = "/api/stream_chat_response";
    const configName = configDropdown.value;
    const requestOptions = {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify({
            last_message: conversation.slice(-1),
            conversation_id: conversation_id,
            config_name: configName,
            is_refresh: isRefresh,
            client_sent_msg_ts: Date.now(),
            client_timeout: DEFAULT_TIMEOUT_SECS * 1000
        }),
        timeout: DEFAULT_TIMEOUT_SECS * 1000
    };

    const response = await fetchWithTimeout(API_URL, requestOptions);
    if (!response.ok || !response.body) {
        throw new Error(`Streaming request failed with status ${response.status}`);
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    const details = incomingChatDiv.querySelector(".chat-details");
    const typingNode = details.querySelector(".typing-animation");
    const loadingNode = details.querySelector("#loading-text");

    let buffer = "";
    let outputElement = null;
    let appended = false;
    let finished = false;
    let placeholdersRemoved = false;

    const ensureOutputElement = () => {
        if (!outputElement) {
            outputElement = document.createElement("div");
            outputElement.classList.add("default-text");
        }
        if (!appended) {
            if (typingNode) {
                typingNode.remove();
                placeholdersRemoved = true;
            }
            if (loadingNode) {
                loadingNode.remove();
                placeholdersRemoved = true;
            }
            details.appendChild(outputElement);
            appended = true;
        }
        return outputElement;
    };

    try {
        while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });

            let newlineIndex;
            while ((newlineIndex = buffer.indexOf("\n")) >= 0) {
                const line = buffer.slice(0, newlineIndex).trim();
                buffer = buffer.slice(newlineIndex + 1);
                if (!line) continue;

                const event = JSON.parse(line);
                if (event.type === "delta") {
                    const element = ensureOutputElement();
                    element.textContent += event.text;
                } else if (event.type === "final") {
                    const element = ensureOutputElement();
                    if (event.response) {
                        element.innerHTML = event.response;
                    }
                    if (event.a2rchi_msg_id) {
                        element.setAttribute('id', event.a2rchi_msg_id.toString());
                    }
                    conversation.push(["A2rchi", event.response]);
                    conversation_id = event.conversation_id;
                    last_response_is_feedback_request = false;
                    localStorage.setItem("all-chats", chatContainer.innerHTML);
                    chatContainer.scrollTo(0, chatContainer.scrollHeight);
                    setTimeout(() => loadConversations(), 500);
                    setTimeout(showFeedbackRequest, 500);
                    finished = true;
                } else if (event.type === "error") {
                    throw new Error(event.message || "Streaming error");
                }
            }
        }
    } catch (error) {
        if (appended && outputElement?.parentElement) {
            outputElement.remove();
        }
        if (!finished && placeholdersRemoved) {
            const imageNode = details.querySelector('img');
            if (typingNode) {
                if (imageNode && imageNode.nextSibling) {
                    details.insertBefore(typingNode, imageNode.nextSibling);
                } else {
                    details.appendChild(typingNode);
                }
            }
            if (loadingNode) {
                details.appendChild(loadingNode);
            }
        }
        throw error;
    } finally {
        reader.releaseLock?.();
    }

    if (!finished) {
        throw new Error("Streaming terminated before final response");
    }
};

const getChatResponse = async (incomingChatDiv, isRefresh=false) => {
    if (STREAM_CHAT_ENABLED) {
        try {
            await streamChatResponse(incomingChatDiv, isRefresh);
            return;
        } catch (error) {
            console.error("Streaming failed, falling back to standard response:", error);
            STREAM_CHAT_ENABLED = false;
        }
    }

    return fetchChatResponse(incomingChatDiv, isRefresh);
};


const copyCode = (copyCodeBtn) => {
    // Copy the text content of the response to the clipboard
    const reponseTextElement = copyCodeBtn.parentElement.parentElement.querySelector(".code-box-body");
    navigator.clipboard.writeText(reponseTextElement.innerText);
}

const copyResponse = (copyBtn) => {
    // Copy the text content of the response to the clipboard
    const reponseTextElement = copyBtn.parentElement.previousElementSibling.querySelector("p");
    navigator.clipboard.writeText(reponseTextElement.textContent);
}

const likeResponse = (likeBtn) => {
    num_responses_since_last_rating = 0;

    // fill the image
    const image = likeBtn.querySelector("img");
    image.src = "/static/images/thumbs_up_filled.png"

    // make sure other image is not filled
    const other_image = likeBtn.nextElementSibling.querySelector("img");
    other_image.src = "/static/images/thumbs_down.png";

    const API_URL = "/api/like";

     // Send an API request with the chat content and discussion ID
     try {
        fetch(API_URL, {
            method: "POST", // You may need to adjust the HTTP method
            headers: {
                "Content-Type": "application/json",
                "Access-Control-Allow-Origin": "*",
            },
            body: JSON.stringify({
                message_id: likeBtn.parentElement.previousElementSibling.querySelector("p").parentElement.id,
            }),
        })
     } catch (error) {
        console.log("liked error message")
     }
}

const dislikeResponse = (dislikeBtn) => {
    num_responses_since_last_rating = 0;

    // fill the image
    const image = dislikeBtn.querySelector("img");
    image.src = "/static/images/thumbs_down_filled.png";

    // make sure other image is not filled
    const other_image = dislikeBtn.previousElementSibling.querySelector("img");
    other_image.src = "/static/images/thumbs_up.png";

    const API_URL = "/api/dislike";

    // Show pop-up form
    popupForm.style.display = "block";

    // Function which handles sending the information in the pop up form to the backend API
    function handleSubmitToAPI() {
        const additionalThoughts = additionalThoughtsInput.value;

        try {
            fetch(API_URL, {
                method: "POST", // You may need to adjust the HTTP method
                headers: {
                    "Content-Type": "application/json",
                    "Access-Control-Allow-Origin": "*",
                },
                body: JSON.stringify({ 
                    message_id: dislikeBtn.parentElement.previousElementSibling.querySelector("p").parentElement.id,
                    feedback_msg: additionalThoughts,
                    incorrect: correct_checkbox.checked,
                    unhelpful: helpful_checkbox.checked,
                    inappropriate: appropriate_checkbox.checked,
                }),
            });
        } catch (error) {
            console.log("disliked error message")
        }

        //hide pop up form
        popupForm.style.display = "none";
    }

    //wait for user to submit response or close the additional feedback window
    submitButton.addEventListener("click", handleSubmitToAPI, {once: true});
    closeButton.addEventListener("click", handleSubmitToAPI, {once: true});
}

const closeFeedback = (closeBtn) => {
    //hide pop up form
    popupForm.style.display = "none";
}

const showTypingAnimation = (isRefresh = false) => {
    // Create the typing animation and append it to the chat container
    const html = `<div class="chat-content">
                    <div class="chat-details">
                        <img src="/static/images/a2rchi.png" alt="chatbot-img">
                        <div class="typing-animation">
                            <div class="typing-dot" style="--delay: 0.2s"></div>
                            <div class="typing-dot" style="--delay: 0.3s"></div>
                            <div class="typing-dot" style="--delay: 0.4s"></div>
                        </div>
                        <p id="loading-text"><em style='color: gray;'>Processing request...</em></p>
                    </div>
                    <div class="button-container">
                        <button onclick="likeResponse(this)" class="material-button">
                            <img src="/static/images/thumbs_up.png" alt="Like" width="30" height="30">
                        </button>
                        <button onclick="dislikeResponse(this)" class="material-button">
                            <img src="/static/images/thumbs_down.png" alt="Dislike" width="30" height="30">
                        </button>
                    </div>
                </div>`;

    // Create an incoming chat div and append it
    const incomingChatDiv = createChatElement(html, "incoming");
    chatContainer.appendChild(incomingChatDiv);
    chatContainer.scrollTo(0, chatContainer.scrollHeight);

    // Get reference to the text element inside the typing animation
    const loadingTextElement = document.getElementById("loading-text");

    const statusMessages = [
        "<em style='color: gray;'>Searching through relevant documents...</em>",
        "<em style='color: gray;'>Almost there... fetching more details.</em>",
        "<em style='color: gray;'>Still processing... please wait a moment, open-source magic happening.</em>"
    ];
    
    let statusIndex = 0;
    
    const statusUpdateInterval = setInterval(() => {
        if (statusIndex < statusMessages.length) {
            loadingTextElement.innerHTML = `${statusMessages[statusIndex]}`;
            statusIndex++;
        }
    }, 10000); // Change message every 10 seconds

    // Call API to get response
    getChatResponse(incomingChatDiv, isRefresh)
        .then(() => {
            clearInterval(statusUpdateInterval); // Stop updates once response arrives
        })
        .catch(() => {
            clearInterval(statusUpdateInterval); // Stop updates on error
        });
};

const showFeedbackRequest = () => {
    // Display a message from A2rchi to ask the user to give feedback

    num_responses_since_last_rating = num_responses_since_last_rating + 1;

    const html = `<div class="chat-content">
                    <div class="chat-details">
                        <img src="/static/images/a2rchi.png" alt="chatbot-img">
                        <div class="default-text">
                            <p>I've noticed you haven't rated any of my responses in a while. Rating responses is crucial because it not only helps me improve, but it also ensures that this project remains open source and freely accessible for everyone. Your input is highly valuable in supporting the A2rchi mission! </p>
                        </div>
                    </div>
                </div>`;
    
    // Create an incoming chat div with feedback request and append it to chat container
    if (num_responses_since_last_rating > 2) {
        const incomingChatDiv = createChatElement(html, "incoming");
        chatContainer.appendChild(incomingChatDiv);
        chatContainer.scrollTo(0, chatContainer.scrollHeight);
        num_responses_since_last_rating = 0;
        last_response_is_feedback_request = true;
    }
}

const handleOutgoingChat = () => {
    userText = chatInput.value.trim(); // Get chatInput value and remove extra spaces
    if(!userText) return; // If chatInput is empty return from here
    conversation.push(["User", userText])

    // Clear the input field and reset its height
    chatInput.value = "";
    chatInput.style.height = `${initialInputHeight}px`;

    const html = `<div class="chat-content">
                    <div class="chat-details">
                        <img src="/static/images/user.svg" alt="user-img">
                        <p>${userText}</p>
                    </div>
                </div>`;

    // Create an outgoing chat div with user's message and append it to chat container
    const outgoingChatDiv = createChatElement(html, "outgoing");
    chatContainer.querySelector(".default-text")?.remove();
    chatContainer.appendChild(outgoingChatDiv);
    chatContainer.scrollTo(0, chatContainer.scrollHeight);
    setTimeout(showTypingAnimation, 500);
}

deleteButton.addEventListener("click", async () => {
    // Remove the chats via api/delete_conversation
    if(confirm("Are you sure you want to delete this chat?")) {
        if (conversation_id !== null) {
            try {
                const response = await fetch("/api/delete_conversation", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({ conversation_id: conversation_id }),
                });
                
                const result = await response.json();
            } catch (error) {
                console.error("Error deleting conversation:", error);
            }
        }
        
        localStorage.removeItem("all-chats");
        startNewConversation();
    }
});

refreshButton.addEventListener("click", () => {
    refreshChat();
});

themeButton.addEventListener("click", () => {
    // Toggle body's class for the theme mode and save the updated theme to the local storage 
    document.body.classList.toggle("light-mode");
    localStorage.setItem("themeColor", themeButton.innerText);
    themeButton.innerText = document.body.classList.contains("light-mode") ? "dark_mode" : "light_mode";
});

const initialInputHeight = chatInput.scrollHeight;

chatInput.addEventListener("input", () => {   
    // Adjust the height of the input field dynamically based on its content
    chatInput.style.height =  `${initialInputHeight}px`;
    chatInput.style.height = `${chatInput.scrollHeight}px`;
});

chatInput.addEventListener("keydown", (e) => {
    // If the Enter key is pressed without Shift and the window width is larger 
    // than 800 pixels, handle the outgoing chat
    if (e.key === "Enter" && !e.shiftKey && window.innerWidth > 800) {
        e.preventDefault();
        handleOutgoingChat();
    }
});

loadDataFromLocalstorage();
populateDropdown();
loadConversations();

// Event listeners for new conversation
newChatButton.addEventListener("click", startNewConversation);

toggleSidebarButton.addEventListener("click", () => {
    const sidebar = document.querySelector(".sidebar");
    const icon = toggleSidebarButton.querySelector(".material-symbols-rounded");
    
    // On mobile (screen width <= 800px), toggle 'hidden' class
    // On desktop, toggle 'collapsed' class
    if (window.innerWidth <= 800) {
        sidebar.classList.toggle("hidden");
        icon.textContent = sidebar.classList.contains("hidden") ? "menu" : "close";
    } else {
        sidebar.classList.toggle("collapsed");
        icon.textContent = sidebar.classList.contains("collapsed") ? "menu" : "chevron_left";
    }
});

sendButton.addEventListener("click", handleOutgoingChat);
