{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A2RCHI A2RCHI (AI Augmented Research Chat Intelligence) is a retrieval-augmented generation (RAG) framework designed to be a low-barrier, open-source, private, and customizable AI solution for research and educational support. A2RCHI makes it easy to deploy AI assistants with a suite of tools that connect to communication platforms such as Piazza, Slack, Discourse, Mattermost, and email, and knowledge bases such as web links, files, JIRA tickets, and documentation. It is modular and extensible, allowing users to add connectors and customise pipeline behaviour for a wide range of tasks\u2014from answering simple questions to delivering detailed explanations. About A2RCHI is an end-to-end framework developed by Prof. Paus (MIT Physics), Prof. Kraska (MIT EECS), and their students. It has already been successfully deployed as a user chatbot and technical assistant at SubMIT (the MIT Physics Department's private cluster) and as an educational assistant for several MIT courses, including 8.01 and 8.511. What sets A2RCHI apart is that it is fully open source, configurable across foundational models and LLM libraries, and designed for private deployment. Under the hood, A2RCHI is a highly configurable RAG system tailored for educational and scientific support. Given its success, the scope now spans additional MIT classes, CERN, Harvard, and internal deployments such as CSAIL's support staff. Educational Support A2RCHI assists TAs, lecturers, and support staff\u2014or students directly\u2014by preparing answers based on curated class resources. In MIT course deployments, A2RCHI leverages Piazza posts, documentation, and other class-specific materials. The Piazza integration can draft answers for staff to review or send, while the system continuously learns from revisions and new posts, improving over time. Research Resource Support A2RCHI also serves technical support teams and end users. At SubMIT, it functions both as a user-facing chatbot and as a ticket assistant. Integration with Redmine enables A2RCHI to prepare draft responses to support tickets that staff can review before sending. In both roles, A2RCHI accesses the corpus of tickets and documentation, citing relevant sources in its answers.","title":"A2RCHI"},{"location":"#a2rchi","text":"A2RCHI (AI Augmented Research Chat Intelligence) is a retrieval-augmented generation (RAG) framework designed to be a low-barrier, open-source, private, and customizable AI solution for research and educational support. A2RCHI makes it easy to deploy AI assistants with a suite of tools that connect to communication platforms such as Piazza, Slack, Discourse, Mattermost, and email, and knowledge bases such as web links, files, JIRA tickets, and documentation. It is modular and extensible, allowing users to add connectors and customise pipeline behaviour for a wide range of tasks\u2014from answering simple questions to delivering detailed explanations.","title":"A2RCHI"},{"location":"#about","text":"A2RCHI is an end-to-end framework developed by Prof. Paus (MIT Physics), Prof. Kraska (MIT EECS), and their students. It has already been successfully deployed as a user chatbot and technical assistant at SubMIT (the MIT Physics Department's private cluster) and as an educational assistant for several MIT courses, including 8.01 and 8.511. What sets A2RCHI apart is that it is fully open source, configurable across foundational models and LLM libraries, and designed for private deployment. Under the hood, A2RCHI is a highly configurable RAG system tailored for educational and scientific support. Given its success, the scope now spans additional MIT classes, CERN, Harvard, and internal deployments such as CSAIL's support staff.","title":"About"},{"location":"#educational-support","text":"A2RCHI assists TAs, lecturers, and support staff\u2014or students directly\u2014by preparing answers based on curated class resources. In MIT course deployments, A2RCHI leverages Piazza posts, documentation, and other class-specific materials. The Piazza integration can draft answers for staff to review or send, while the system continuously learns from revisions and new posts, improving over time.","title":"Educational Support"},{"location":"#research-resource-support","text":"A2RCHI also serves technical support teams and end users. At SubMIT, it functions both as a user-facing chatbot and as a ticket assistant. Integration with Redmine enables A2RCHI to prepare draft responses to support tickets that staff can review before sending. In both roles, A2RCHI accesses the corpus of tickets and documentation, citing relevant sources in its answers.","title":"Research Resource Support"},{"location":"advanced_setup_deploy/","text":"Advanced Setup & Deployment Topics related to advanced setup and deployment of A2RCHI. Configuring Podman To ensure your Podman containers stay running for extended periods, you need to enable lingering. To do this, run: loginctl enable-linger To check or confirm the lingering status, run: loginctl user-status | grep -m1 Linger See the Red Hat documentation for additional context. Running LLMs locally on your GPUs There are a few additional system requirements for this to work: Make sure you have NVIDIA drivers installed. (Optional) For the containers where A2RCHI will run to access the GPUs, install the NVIDIA container toolkit . Configure the container runtime to access the GPUs. For Podman Run the following command: sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml Then list the devices: nvidia-ctk cdi list You should see output similar to: INFO[0000] Found 9 CDI devices ... nvidia.com/gpu=0 nvidia.com/gpu=1 ... nvidia.com/gpu=all ... These listed \"CDI devices\" will be referenced to run A2RCHI on the GPUs, so make sure they are present. To learn more, consult the [Podman GPU documentation](https://podman-desktop.io/docs/podman/gpu). For Docker Run the following command: sudo nvidia-ctk runtime configure --runtime=docker The remaining steps mirror the Podman flow. NOTE: this has not yet been fully tested with Docker. Refer to the [NVIDIA toolkit documentation](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html#configuration) for details. Once these requirements are met, the a2rchi create [...] --gpu-ids <gpus> option will deploy A2RCHI across your GPUs. Helpful Notes for Production Deployments You may wish to use the CLI in order to stage production deployments. This section covers some useful notes to keep in mind. Running multiple deployments on the same machine The CLI allows multiple deployments to run on the same daemon in the case of Docker (Podman has no daemon). The container networks between all the deployments are separate, so there is very little risk of them accidentally communicating with one another. However, you need to be careful with the external ports. Suppose you're running two deployments and both of them are running the chat on external port 8000. There is no way to view both deployments at the same time from the same port, so instead you should forward the deployments to other external ports. Generally, this can be done in the configuration: services: chat_app: external_port: 7862 # default is 7861 uploader_app: external_port: 5004 # default is 5003 grafana: external_port: 3001 # default is 3000 chromadb: chromadb_external_port: 8001 # default is 8000 Persisting data between deployments Volumes persist between deployments, so if you deploy an instance and upload additional documents, you do not need to redo this every time you deploy. If you are editing any data, explicitly remove this information from the volume, or remove the volume itself with: docker/podman volume rm <volume-name> To see what volumes are currently present, run: docker/podman volume ls","title":"Advanced Setup and Deployment"},{"location":"advanced_setup_deploy/#advanced-setup-deployment","text":"Topics related to advanced setup and deployment of A2RCHI.","title":"Advanced Setup &amp; Deployment"},{"location":"advanced_setup_deploy/#configuring-podman","text":"To ensure your Podman containers stay running for extended periods, you need to enable lingering. To do this, run: loginctl enable-linger To check or confirm the lingering status, run: loginctl user-status | grep -m1 Linger See the Red Hat documentation for additional context.","title":"Configuring Podman"},{"location":"advanced_setup_deploy/#running-llms-locally-on-your-gpus","text":"There are a few additional system requirements for this to work: Make sure you have NVIDIA drivers installed. (Optional) For the containers where A2RCHI will run to access the GPUs, install the NVIDIA container toolkit . Configure the container runtime to access the GPUs. For Podman Run the following command: sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml Then list the devices: nvidia-ctk cdi list You should see output similar to: INFO[0000] Found 9 CDI devices ... nvidia.com/gpu=0 nvidia.com/gpu=1 ... nvidia.com/gpu=all ... These listed \"CDI devices\" will be referenced to run A2RCHI on the GPUs, so make sure they are present. To learn more, consult the [Podman GPU documentation](https://podman-desktop.io/docs/podman/gpu). For Docker Run the following command: sudo nvidia-ctk runtime configure --runtime=docker The remaining steps mirror the Podman flow. NOTE: this has not yet been fully tested with Docker. Refer to the [NVIDIA toolkit documentation](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html#configuration) for details. Once these requirements are met, the a2rchi create [...] --gpu-ids <gpus> option will deploy A2RCHI across your GPUs.","title":"Running LLMs locally on your GPUs"},{"location":"advanced_setup_deploy/#helpful-notes-for-production-deployments","text":"You may wish to use the CLI in order to stage production deployments. This section covers some useful notes to keep in mind.","title":"Helpful Notes for Production Deployments"},{"location":"advanced_setup_deploy/#running-multiple-deployments-on-the-same-machine","text":"The CLI allows multiple deployments to run on the same daemon in the case of Docker (Podman has no daemon). The container networks between all the deployments are separate, so there is very little risk of them accidentally communicating with one another. However, you need to be careful with the external ports. Suppose you're running two deployments and both of them are running the chat on external port 8000. There is no way to view both deployments at the same time from the same port, so instead you should forward the deployments to other external ports. Generally, this can be done in the configuration: services: chat_app: external_port: 7862 # default is 7861 uploader_app: external_port: 5004 # default is 5003 grafana: external_port: 3001 # default is 3000 chromadb: chromadb_external_port: 8001 # default is 8000","title":"Running multiple deployments on the same machine"},{"location":"advanced_setup_deploy/#persisting-data-between-deployments","text":"Volumes persist between deployments, so if you deploy an instance and upload additional documents, you do not need to redo this every time you deploy. If you are editing any data, explicitly remove this information from the volume, or remove the volume itself with: docker/podman volume rm <volume-name> To see what volumes are currently present, run: docker/podman volume ls","title":"Persisting data between deployments"},{"location":"api_reference/","text":"API Reference CLI The A2RCHI CLI provides commands to create, manage, and delete A2RCHI deployments and services. Commands 1. create Create a new A2RCHI deployment. Usage: a2rchi create --name <deployment_name> --config <config.yaml> --env-file <secrets.env> [OPTIONS] Options: --name, -n (str, required): Name of the deployment. --config, -c (str): Path to a YAML configuration file (repeat the flag to supply multiple files). --config-dir, -cd (str): Directory containing configuration files. --env-file, -e (str, required): Path to the secrets .env file. --services, -s (comma-separated, required): List of services to enable (e.g., chatbot,uploader ). --sources, -src (comma-separated): Additional data sources to enable (e.g., git,jira ). The links source is always available. --podman, -p : Use Podman instead of Docker. --gpu-ids : GPU configuration ( all or comma-separated IDs). --tag, -t (str): Image tag for built containers (default: 2000 ). --hostmode : Use host network mode. --verbosity, -v (int): Logging verbosity (0-4, default: 3). --force, -f : Overwrite existing deployment if it exists. --dry, --dry-run : Validate and show what would be created, but do not deploy. 2. delete Delete an existing A2RCHI deployment. Usage: a2rchi delete --name <deployment_name> [OPTIONS] Options: --name, -n (str): Name of the deployment to delete. --rmi : Remove container images. --rmv : Remove volumes. --keep-files : Keep deployment files (do not remove directory). --list : List all available deployments. 3. list-services List all available A2RCHI services and data sources. Usage: a2rchi list-services 4. list-deployments List all existing A2RCHI deployments. Usage: a2rchi list-deployments 5. evaluate Launch the benchmarking runtime to evaluate one or more configurations against a set of questions/answers. Usage: a2rchi evaluate --name <run_name> --env-file <secrets.env> --config <file.yaml> [OPTIONS] Use --config-dir if you want to point to a directory of configs instead. Options: Supports the same flags as create ( --sources , --podman , --gpu-ids , --tag , --hostmode , --verbosity , --force ). Reads configuration from one or more YAML files that should define the services.benchmarking section. Examples Create a deployment: a2rchi create --name mybot --config my.yaml --env-file secrets.env --services chatbot,uploader Delete a deployment and remove images/volumes: a2rchi delete --name mybot --rmi --rmv List all deployments: a2rchi list-deployments List all services: a2rchi list-services Configuration YAML API Reference The A2RCHI configuration YAML file defines the deployment, services, data sources, pipelines, models, and interface settings for your A2RCHI instance. Top-Level Fields name Type: string Description: Name of the deployment. global DATA_PATH: path for persisted data (defaults to /root/data/ ). ACCOUNTS_PATH: path for uploader/grader account data. ACCEPTED_FILES: list of extensions allowed for manual uploads. LOGGING.input_output_filename: log file that stores pipeline inputs/outputs. verbosity: default logging level for services (0-4). services Holds configuration for every containerised service. Common keys include: port / external_port: internal versus host port mapping for web apps. host / hostname: network binding and public hostname for frontends. volume/paths: template or static asset paths expected by the service. Key services: chat_app: Chat interface options ( trained_on , ports, UI toggles). uploader_app: Document uploader settings ( verify_urls , ports). grader_app: Grader-specific knobs ( num_problems , rubric paths). grafana: Port configuration for the monitoring dashboard. chromadb: Connection details for the vector store container ( chromadb_host , chromadb_port , chromadb_external_port ). postgres: Database credentials ( user , database , port , host ). piazza , mattermost , redmine_mailbox , benchmarking , ...: Service-specific options (see user guide sections above). data_manager Controls ingestion sources and vector store behaviour. sources.links.input_lists: .list files with seed URLs. sources.links.scraper: Behaviour toggles for HTTP scraping (resetting data, URL verification, warning output). sources. .visible: Mark whether documents harvested from a source should appear in chat citations and other user-facing listings ( true by default). sources.git.enabled / sources.sso.enabled / sources.jira.enabled / sources.redmine.enabled: Toggle additional collectors when paired with --sources . embedding_name: Embedding backend ( OpenAIEmbeddings , HuggingFaceEmbeddings , ...). embedding_class_map: Backend specific parameters (model name, device, similarity threshold). chunk_size / chunk_overlap: Text splitter parameters. reset_collection: Whether to wipe the collection before re-populating. num_documents_to_retrieve: Top-k documents returned at query time. distance_metric / use_hybrid_search / bm25_weight / semantic_weight / bm25.{k1,b}: Retrieval tuning knobs. utils.anonymizer (legacy) / data_manager.utils.anonymizer : Redaction settings applied when ticket collectors anonymise content. a2rchi Defines pipelines and model routing. pipelines: List of pipeline names to load (e.g., QAPipeline ). pipeline_map: Per-pipeline configuration of prompts, models, and token limits. model_class_map: Definitions for each model family (base model names, provider-specific kwargs). chain_update_time: Polling interval for hot-reloading chains. utils Utility configuration for supporting components (mostly legacy fallbacks): sso: Global SSO defaults used when a source-specific override is not provided. git: Legacy toggle for Git scraping. jira / redmine: Compatibility settings for ticket integrations; prefer configuring these under data_manager.sources . Required Fields Some fields are required depending on enabled services and pipelines. For example: name data_manager.sources.links.input_lists (or other source-specific configuration) a2rchi.pipelines and matching a2rchi.pipeline_map entries Service-specific fields (e.g., services.piazza.network_id , services.grader_app.num_problems ) See the User Guide for more configuration examples and explanations. Example name: my_deployment global: DATA_PATH: \"/root/data/\" ACCOUNTS_PATH: \"/root/.accounts/\" ACCEPTED_FILES: [\".txt\", \".pdf\"] LOGGING: input_output_filename: \"chain_input_output.log\" verbosity: 3 data_manager: sources: links: input_lists: - examples/deployments/basic-gpu/miscellanea.list scraper: reset_data: true verify_urls: false enable_warnings: false utils: anonymizer: nlp_model: en_core_web_sm embedding_name: \"OpenAIEmbeddings\" chunk_size: 1000 chunk_overlap: 0 num_documents_to_retrieve: 5 a2rchi: pipelines: [\"QAPipeline\"] pipeline_map: QAPipeline: max_tokens: 10000 prompts: required: condense_prompt: \"examples/deployments/basic-gpu/condense.prompt\" chat_prompt: \"examples/deployments/basic-gpu/qa.prompt\" models: required: condense_model: \"OpenAIGPT4\" chat_model: \"OpenAIGPT4\" model_class_map: OpenAIGPT4: class: OpenAIGPT4 kwargs: model_name: gpt-4 services: chat_app: trained_on: \"Course documentation\" hostname: \"example.mit.edu\" chromadb: chromadb_host: \"chromadb\" Tip: For a full template, see src/cli/templates/base-config.yaml in the repository.","title":"API Reference"},{"location":"api_reference/#api-reference","text":"","title":"API Reference"},{"location":"api_reference/#cli","text":"The A2RCHI CLI provides commands to create, manage, and delete A2RCHI deployments and services.","title":"CLI"},{"location":"api_reference/#commands","text":"","title":"Commands"},{"location":"api_reference/#1-create","text":"Create a new A2RCHI deployment. Usage: a2rchi create --name <deployment_name> --config <config.yaml> --env-file <secrets.env> [OPTIONS] Options: --name, -n (str, required): Name of the deployment. --config, -c (str): Path to a YAML configuration file (repeat the flag to supply multiple files). --config-dir, -cd (str): Directory containing configuration files. --env-file, -e (str, required): Path to the secrets .env file. --services, -s (comma-separated, required): List of services to enable (e.g., chatbot,uploader ). --sources, -src (comma-separated): Additional data sources to enable (e.g., git,jira ). The links source is always available. --podman, -p : Use Podman instead of Docker. --gpu-ids : GPU configuration ( all or comma-separated IDs). --tag, -t (str): Image tag for built containers (default: 2000 ). --hostmode : Use host network mode. --verbosity, -v (int): Logging verbosity (0-4, default: 3). --force, -f : Overwrite existing deployment if it exists. --dry, --dry-run : Validate and show what would be created, but do not deploy.","title":"1. create"},{"location":"api_reference/#2-delete","text":"Delete an existing A2RCHI deployment. Usage: a2rchi delete --name <deployment_name> [OPTIONS] Options: --name, -n (str): Name of the deployment to delete. --rmi : Remove container images. --rmv : Remove volumes. --keep-files : Keep deployment files (do not remove directory). --list : List all available deployments.","title":"2. delete"},{"location":"api_reference/#3-list-services","text":"List all available A2RCHI services and data sources. Usage: a2rchi list-services","title":"3. list-services"},{"location":"api_reference/#4-list-deployments","text":"List all existing A2RCHI deployments. Usage: a2rchi list-deployments","title":"4. list-deployments"},{"location":"api_reference/#5-evaluate","text":"Launch the benchmarking runtime to evaluate one or more configurations against a set of questions/answers. Usage: a2rchi evaluate --name <run_name> --env-file <secrets.env> --config <file.yaml> [OPTIONS] Use --config-dir if you want to point to a directory of configs instead. Options: Supports the same flags as create ( --sources , --podman , --gpu-ids , --tag , --hostmode , --verbosity , --force ). Reads configuration from one or more YAML files that should define the services.benchmarking section.","title":"5. evaluate"},{"location":"api_reference/#examples","text":"Create a deployment: a2rchi create --name mybot --config my.yaml --env-file secrets.env --services chatbot,uploader Delete a deployment and remove images/volumes: a2rchi delete --name mybot --rmi --rmv List all deployments: a2rchi list-deployments List all services: a2rchi list-services","title":"Examples"},{"location":"api_reference/#configuration-yaml-api-reference","text":"The A2RCHI configuration YAML file defines the deployment, services, data sources, pipelines, models, and interface settings for your A2RCHI instance.","title":"Configuration YAML API Reference"},{"location":"api_reference/#top-level-fields","text":"","title":"Top-Level Fields"},{"location":"api_reference/#name","text":"Type: string Description: Name of the deployment.","title":"name"},{"location":"api_reference/#global","text":"DATA_PATH: path for persisted data (defaults to /root/data/ ). ACCOUNTS_PATH: path for uploader/grader account data. ACCEPTED_FILES: list of extensions allowed for manual uploads. LOGGING.input_output_filename: log file that stores pipeline inputs/outputs. verbosity: default logging level for services (0-4).","title":"global"},{"location":"api_reference/#services","text":"Holds configuration for every containerised service. Common keys include: port / external_port: internal versus host port mapping for web apps. host / hostname: network binding and public hostname for frontends. volume/paths: template or static asset paths expected by the service. Key services: chat_app: Chat interface options ( trained_on , ports, UI toggles). uploader_app: Document uploader settings ( verify_urls , ports). grader_app: Grader-specific knobs ( num_problems , rubric paths). grafana: Port configuration for the monitoring dashboard. chromadb: Connection details for the vector store container ( chromadb_host , chromadb_port , chromadb_external_port ). postgres: Database credentials ( user , database , port , host ). piazza , mattermost , redmine_mailbox , benchmarking , ...: Service-specific options (see user guide sections above).","title":"services"},{"location":"api_reference/#data_manager","text":"Controls ingestion sources and vector store behaviour. sources.links.input_lists: .list files with seed URLs. sources.links.scraper: Behaviour toggles for HTTP scraping (resetting data, URL verification, warning output). sources. .visible: Mark whether documents harvested from a source should appear in chat citations and other user-facing listings ( true by default). sources.git.enabled / sources.sso.enabled / sources.jira.enabled / sources.redmine.enabled: Toggle additional collectors when paired with --sources . embedding_name: Embedding backend ( OpenAIEmbeddings , HuggingFaceEmbeddings , ...). embedding_class_map: Backend specific parameters (model name, device, similarity threshold). chunk_size / chunk_overlap: Text splitter parameters. reset_collection: Whether to wipe the collection before re-populating. num_documents_to_retrieve: Top-k documents returned at query time. distance_metric / use_hybrid_search / bm25_weight / semantic_weight / bm25.{k1,b}: Retrieval tuning knobs. utils.anonymizer (legacy) / data_manager.utils.anonymizer : Redaction settings applied when ticket collectors anonymise content.","title":"data_manager"},{"location":"api_reference/#a2rchi","text":"Defines pipelines and model routing. pipelines: List of pipeline names to load (e.g., QAPipeline ). pipeline_map: Per-pipeline configuration of prompts, models, and token limits. model_class_map: Definitions for each model family (base model names, provider-specific kwargs). chain_update_time: Polling interval for hot-reloading chains.","title":"a2rchi"},{"location":"api_reference/#utils","text":"Utility configuration for supporting components (mostly legacy fallbacks): sso: Global SSO defaults used when a source-specific override is not provided. git: Legacy toggle for Git scraping. jira / redmine: Compatibility settings for ticket integrations; prefer configuring these under data_manager.sources .","title":"utils"},{"location":"api_reference/#required-fields","text":"Some fields are required depending on enabled services and pipelines. For example: name data_manager.sources.links.input_lists (or other source-specific configuration) a2rchi.pipelines and matching a2rchi.pipeline_map entries Service-specific fields (e.g., services.piazza.network_id , services.grader_app.num_problems ) See the User Guide for more configuration examples and explanations.","title":"Required Fields"},{"location":"api_reference/#example","text":"name: my_deployment global: DATA_PATH: \"/root/data/\" ACCOUNTS_PATH: \"/root/.accounts/\" ACCEPTED_FILES: [\".txt\", \".pdf\"] LOGGING: input_output_filename: \"chain_input_output.log\" verbosity: 3 data_manager: sources: links: input_lists: - examples/deployments/basic-gpu/miscellanea.list scraper: reset_data: true verify_urls: false enable_warnings: false utils: anonymizer: nlp_model: en_core_web_sm embedding_name: \"OpenAIEmbeddings\" chunk_size: 1000 chunk_overlap: 0 num_documents_to_retrieve: 5 a2rchi: pipelines: [\"QAPipeline\"] pipeline_map: QAPipeline: max_tokens: 10000 prompts: required: condense_prompt: \"examples/deployments/basic-gpu/condense.prompt\" chat_prompt: \"examples/deployments/basic-gpu/qa.prompt\" models: required: condense_model: \"OpenAIGPT4\" chat_model: \"OpenAIGPT4\" model_class_map: OpenAIGPT4: class: OpenAIGPT4 kwargs: model_name: gpt-4 services: chat_app: trained_on: \"Course documentation\" hostname: \"example.mit.edu\" chromadb: chromadb_host: \"chromadb\" Tip: For a full template, see src/cli/templates/base-config.yaml in the repository.","title":"Example"},{"location":"developer_guide/","text":"Developers Guide Below is all the information developers may need to get started contributing to the A2RCHI project. Editing Documentation Editing documentation requires the mkdocs Python package: pip install mkdocs To edit documentation, update the .md and .yml files in the ./docs folder. To preview changes locally, run: cd docs mkdocs serve Add the -a IP:HOST argument (default is localhost:8000 ) to specify the host and port. Publish your changes with: mkdocs gh-deploy Always open a PR to merge documentation changes into main . Do not edit files directly in the gh-pages branch. DockerHub Images A2RCHI loads different base images hosted on Docker Hub. The Python base image is used when GPUs are not required; otherwise the PyTorch base image is used. The Dockerfiles for these base images live in src/cli/templates/dockerfiles/base-X-image . Images are hosted at: Python: https://hub.docker.com/r/a2rchi/a2rchi-python-base PyTorch: https://hub.docker.com/r/a2rchi/a2rchi-pytorch-base To rebuild a base image, navigate to the relevant base-xxx-image directory under src/cli/templates/dockerfiles/ . Each directory contains the Dockerfile, requirements, and license information. Regenerate the requirements files with: # Python image cat requirements/cpu-requirementsHEADER.txt requirements/requirements-base.txt > src/cli/templates/dockerfiles/base-python-image/requirements.txt # PyTorch image cat requirements/gpu-requirementsHEADER.txt requirements/requirements-base.txt > src/cli/templates/dockerfiles/base-pytorch-image/requirements.txt Build the image: podman build -t a2rchi/<image-name>:<tag> . After verifying the image, log in to Docker Hub (ask a senior developer for credentials): podman login docker.io Push the image: podman push a2rchi/<image-name>:<tag> Data Ingestion Architecture A2RCHI ingests content through sources which are collected by collectors ( data_manager/collectors ). These documents are written to persistent, local files via the PersistenceService , which uses Resource objects as an abstraction for different content types, and ResourceMetadata for associated metadata. A catalog of persisted files is maintained in index.yaml and metadata_index.yaml . Finally, the VectorStoreManager reads these files, splits them into chunks, generates embeddings, and indexes them in ChromaDB. Resources and BaseResource Every collected artifact from the collectors is represented as a subclass of BaseResource ( src/data_manager/collectors/resource_base.py ). Subclasses must implement: get_hash() : a stable identifier used as the key in the filesystem catalog. get_filename() : the on-disk file name (including extension). get_content() : returns the textual or binary payload that should be persisted. Resources may optionally override: get_metadata() : returns a metadata object (typically ResourceMetadata ) describing the item. Keys should be serialisable strings and are flattened into the vector store metadata. get_metadata_path() : inherited helper that derives a .meta.yaml path when metadata is present. ResourceMetadata ( src/data_manager/collectors/utils/metadata.py ) enforces a required display_name and normalises the extra dictionary so all values become strings. Use this to expose source-specific information such as URLs, ticket identifiers, or visibility flags. The guiding philosophy is that resources describe content , but never write to disk themselves. This separation keeps collectors simple, testable, and ensures consistent validation when persisting different resource types. Persistence Service PersistenceService ( src/data_manager/collectors/persistence.py ) centralises all filesystem writes for both the document content, and its metadata. When persist_resource() is called it: Resolves the target path under the configured DATA_PATH . Validates and writes the resource content (rejecting empty payloads or unknown types). Serialises metadata, if provided, to an adjacent *.meta.yaml file. Updates two catalogs: index.yaml : maps each resource hash to the content file path. metadata_index.yaml : maps resource hashes to the metadata file path. Collectors only interact with PersistenceService ; they should not touch the filesystem directly. Vector Database The vector store lives under the data_manager/vectorstore package. VectorStoreManager reads the persistence catalogs and synchronises them with ChromaDB: Loads the tracked files and metadata hashes from index.yaml . Splits documents into chunks, optional stemming, and builds embeddings via the configured model. Adds chunks to the Chroma collection with flattened metadata (including resource hash, filename, human-readable display fields, and any source-specific extras). Deletes stale entries when the underlying files disappear or are superseded. Because the manager defers to the catalog, any resource persisted through PersistenceService automatically becomes eligible for indexing\u2014no extra plumbing is required. Extending the stack When integrating a new source, create a collector under data_manager/collectors . Collectors should yield Resource objects. A new Resource subclass is only needed if the content type is not already represented (e.g., text, HTML, markdown, images, etc.), but it must implement the required methods described above. When integrating a new collector, ensure that any per-source configuration is encoded in the resource metadata so downstream consumers\u2014such as the chat app\u2014can honour it. When extending the embedding pipeline or storage schema, keep this flow in mind: collectors produce resources \u2192 PersistenceService writes files and updates indexes \u2192 VectorStoreManager promotes the indexed files into Chroma. Keeping responsibilities narrowly scoped makes the ingestion stack easier to reason about and evolve.","title":"Developer Guide"},{"location":"developer_guide/#developers-guide","text":"Below is all the information developers may need to get started contributing to the A2RCHI project.","title":"Developers Guide"},{"location":"developer_guide/#editing-documentation","text":"Editing documentation requires the mkdocs Python package: pip install mkdocs To edit documentation, update the .md and .yml files in the ./docs folder. To preview changes locally, run: cd docs mkdocs serve Add the -a IP:HOST argument (default is localhost:8000 ) to specify the host and port. Publish your changes with: mkdocs gh-deploy Always open a PR to merge documentation changes into main . Do not edit files directly in the gh-pages branch.","title":"Editing Documentation"},{"location":"developer_guide/#dockerhub-images","text":"A2RCHI loads different base images hosted on Docker Hub. The Python base image is used when GPUs are not required; otherwise the PyTorch base image is used. The Dockerfiles for these base images live in src/cli/templates/dockerfiles/base-X-image . Images are hosted at: Python: https://hub.docker.com/r/a2rchi/a2rchi-python-base PyTorch: https://hub.docker.com/r/a2rchi/a2rchi-pytorch-base To rebuild a base image, navigate to the relevant base-xxx-image directory under src/cli/templates/dockerfiles/ . Each directory contains the Dockerfile, requirements, and license information. Regenerate the requirements files with: # Python image cat requirements/cpu-requirementsHEADER.txt requirements/requirements-base.txt > src/cli/templates/dockerfiles/base-python-image/requirements.txt # PyTorch image cat requirements/gpu-requirementsHEADER.txt requirements/requirements-base.txt > src/cli/templates/dockerfiles/base-pytorch-image/requirements.txt Build the image: podman build -t a2rchi/<image-name>:<tag> . After verifying the image, log in to Docker Hub (ask a senior developer for credentials): podman login docker.io Push the image: podman push a2rchi/<image-name>:<tag>","title":"DockerHub Images"},{"location":"developer_guide/#data-ingestion-architecture","text":"A2RCHI ingests content through sources which are collected by collectors ( data_manager/collectors ). These documents are written to persistent, local files via the PersistenceService , which uses Resource objects as an abstraction for different content types, and ResourceMetadata for associated metadata. A catalog of persisted files is maintained in index.yaml and metadata_index.yaml . Finally, the VectorStoreManager reads these files, splits them into chunks, generates embeddings, and indexes them in ChromaDB.","title":"Data Ingestion Architecture"},{"location":"developer_guide/#resources-and-baseresource","text":"Every collected artifact from the collectors is represented as a subclass of BaseResource ( src/data_manager/collectors/resource_base.py ). Subclasses must implement: get_hash() : a stable identifier used as the key in the filesystem catalog. get_filename() : the on-disk file name (including extension). get_content() : returns the textual or binary payload that should be persisted. Resources may optionally override: get_metadata() : returns a metadata object (typically ResourceMetadata ) describing the item. Keys should be serialisable strings and are flattened into the vector store metadata. get_metadata_path() : inherited helper that derives a .meta.yaml path when metadata is present. ResourceMetadata ( src/data_manager/collectors/utils/metadata.py ) enforces a required display_name and normalises the extra dictionary so all values become strings. Use this to expose source-specific information such as URLs, ticket identifiers, or visibility flags. The guiding philosophy is that resources describe content , but never write to disk themselves. This separation keeps collectors simple, testable, and ensures consistent validation when persisting different resource types.","title":"Resources and BaseResource"},{"location":"developer_guide/#persistence-service","text":"PersistenceService ( src/data_manager/collectors/persistence.py ) centralises all filesystem writes for both the document content, and its metadata. When persist_resource() is called it: Resolves the target path under the configured DATA_PATH . Validates and writes the resource content (rejecting empty payloads or unknown types). Serialises metadata, if provided, to an adjacent *.meta.yaml file. Updates two catalogs: index.yaml : maps each resource hash to the content file path. metadata_index.yaml : maps resource hashes to the metadata file path. Collectors only interact with PersistenceService ; they should not touch the filesystem directly.","title":"Persistence Service"},{"location":"developer_guide/#vector-database","text":"The vector store lives under the data_manager/vectorstore package. VectorStoreManager reads the persistence catalogs and synchronises them with ChromaDB: Loads the tracked files and metadata hashes from index.yaml . Splits documents into chunks, optional stemming, and builds embeddings via the configured model. Adds chunks to the Chroma collection with flattened metadata (including resource hash, filename, human-readable display fields, and any source-specific extras). Deletes stale entries when the underlying files disappear or are superseded. Because the manager defers to the catalog, any resource persisted through PersistenceService automatically becomes eligible for indexing\u2014no extra plumbing is required.","title":"Vector Database"},{"location":"developer_guide/#extending-the-stack","text":"When integrating a new source, create a collector under data_manager/collectors . Collectors should yield Resource objects. A new Resource subclass is only needed if the content type is not already represented (e.g., text, HTML, markdown, images, etc.), but it must implement the required methods described above. When integrating a new collector, ensure that any per-source configuration is encoded in the resource metadata so downstream consumers\u2014such as the chat app\u2014can honour it. When extending the embedding pipeline or storage schema, keep this flow in mind: collectors produce resources \u2192 PersistenceService writes files and updates indexes \u2192 VectorStoreManager promotes the indexed files into Chroma. Keeping responsibilities narrowly scoped makes the ingestion stack easier to reason about and evolve.","title":"Extending the stack"},{"location":"install/","text":"Install System Requirements A2RCHI is deployed using a Python-based CLI onto containers. It requires: docker version 24+ or podman version 5.4.0+ (for containers) python 3.10.0+ (for the CLI) Note: We support either running open-source models locally or connecting to existing APIs. If you plan to run open-source models on your machine's GPUs, see the Advanced Setup & Deployment section. Installation Clone the A2RCHI repository: git clone https://github.com/mit-submit/A2rchi.git Install A2RCHI (from inside the repository): pip install -e . This installs A2RCHI's dependencies and the CLI tool. Verify the installation with: which a2rchi The command prints the path to the a2rchi executable. Show Full Installation Script # Clone the repository git clone https://github.com/mit-submit/A2rchi.git cd A2rchi export A2RCHI_DIR=$(pwd) # (Optional) Create and activate a virtual environment python3 -m venv .a2rchi_venv source .a2rchi_venv/bin/activate # Install dependencies cd \"$A2RCHI_DIR\" pip install -e . # Verify installation which a2rchi","title":"Install"},{"location":"install/#install","text":"","title":"Install"},{"location":"install/#system-requirements","text":"A2RCHI is deployed using a Python-based CLI onto containers. It requires: docker version 24+ or podman version 5.4.0+ (for containers) python 3.10.0+ (for the CLI) Note: We support either running open-source models locally or connecting to existing APIs. If you plan to run open-source models on your machine's GPUs, see the Advanced Setup & Deployment section.","title":"System Requirements"},{"location":"install/#installation","text":"Clone the A2RCHI repository: git clone https://github.com/mit-submit/A2rchi.git Install A2RCHI (from inside the repository): pip install -e . This installs A2RCHI's dependencies and the CLI tool. Verify the installation with: which a2rchi The command prints the path to the a2rchi executable. Show Full Installation Script # Clone the repository git clone https://github.com/mit-submit/A2rchi.git cd A2rchi export A2RCHI_DIR=$(pwd) # (Optional) Create and activate a virtual environment python3 -m venv .a2rchi_venv source .a2rchi_venv/bin/activate # Install dependencies cd \"$A2RCHI_DIR\" pip install -e . # Verify installation which a2rchi","title":"Installation"},{"location":"quickstart/","text":"Quickstart Deploy your first instance of A2RCHI and walk through the important concepts. Sources and Services A2RCHI can ingest data from a variety of sources and supports several services . List them with the CLI command below and decide which ones you want to use so that we can configure them. a2rchi list-services Example output: Available A2RCHI services: Application Services: chatbot Interactive chat interface for users to communicate with the AI agent grafana Monitoring dashboard for system and LLM performance metrics uploader Admin interface for uploading and managing documents grader Automated grading service for assignments with web interface Integration Services: piazza Integration service for Piazza posts and Slack notifications mattermost Integration service for Mattermost channels redmine-mailer Email processing and Cleo/Redmine ticket management Data Sources: git Git repository scraping for MkDocs-based documentation jira Jira issue tracking integration redmine Redmine ticket integration sso SSO-backed web crawling See the User Guide for detailed information about each service and source. Pipelines A2RCHI supports several pipelines\u2014pre-defined sequences of operations that process user inputs and generate responses. Each service supports a subset of pipelines (see the User Guide for details). An example pipeline is QAPipeline , a question-answering pipeline that takes a user's question, retrieves relevant documents from the vector store, and generates an answer using a language model. You specify which pipelines should be available in the configuration file. Configuration Once you have chosen the services, sources, and pipelines you want to use, create a configuration file that specifies their settings. You can start from one of the example configuration files under examples/deployments/ , or create your own from scratch. This file sets parameters; the selected services and sources are determined at deployment time. Important: The configuration file follows the format of src/cli/templates/base-config.yaml . Any fields not specified in your configuration will be populated with the defaults from this template. Example configuration ( examples/deployments/basic-gpu/config.yaml ) for the chatbot service using QAPipeline with a local VLLM model: name: my_a2rchi data_manager: sources: links: visible: true # include scraped pages in the chat citations input_lists: - examples/deployments/basic-gpu/miscellanea.list embedding_name: HuggingFaceEmbeddings chunk_size: 1000 a2rchi: pipelines: - QAPipeline pipeline_map: QAPipeline: prompts: required: condense_prompt: examples/deployments/basic-gpu/condense.prompt chat_prompt: examples/deployments/basic-gpu/qa.prompt models: required: chat_model: VLLM condense_model: VLLM model_class_map: VLLM: kwargs: base_model: deepseek-ai/DeepSeek-R1-Distill-Qwen-1.5B services: chat_app: trained_on: \"My data\" hostname: \"<your-hostname>\" chromadb: chromadb_host: localhost Explanation of configuration parameters - `name`: Name of your A2RCHI deployment. - `data_manager`: Settings related to data ingestion and the vector store. - `sources.links.input_lists`: Lists of URLs to seed the deployment. - `sources. .visible`: Controls whether content from a given source should be surfaced to end users (defaults to `true`). - `embedding_name`: Embedding model used for vectorization. - `chunk_size`: Controls how documents are split prior to embedding. - `a2rchi`: Core pipeline settings. - `pipelines`: Pipelines to use (e.g., `QAPipeline`). - `pipeline_map`: Configuration for each pipeline, including prompts and models. - `model_class_map`: Mapping of model names to their classes and parameters. - `services`: Settings for individual services/interfaces. - `chat_app`: Chat interface configuration, including hostname and descriptive metadata. - `chromadb`: Connection details for the vector store container. Secrets Secrets are sensitive values (passwords, API keys, etc.) that should not be stored directly in code or configuration files. Store them in a single .env file on your filesystem. Minimal deployments (chatbot with open-source LLM and embeddings) require: PG_PASSWORD : password used to secure the database. Create the secrets file with: echo \"PG_PASSWORD=my_strong_password\" > ~/.secrets.env If you are not using open-source models, supply the relevant API credentials: OPENAI_API_KEY : OpenAI API key. ANTHROPIC_API_KEY : Anthropic API key. HUGGINGFACEHUB_API_TOKEN : HuggingFace access token (for private models or embeddings). Other services may require additional secrets; see the User Guide for details. Creating an A2RCHI Deployment Create your deployment with the CLI: a2rchi create --name my-a2rchi --config examples/deployments/basic-gpu/config.yaml --podman --env-file .secrets.env --services chatbot --gpu-ids all This command specifies: --name : Deployment name. --config : Path to the configuration file. --podman : Use Podman for container management ( docker is the default). --env-file : Path to the secrets file. --services : Services to deploy (only the chatbot service in this example but others can be included separated by commas). Note that this command will create a deployment using only the link sources specified in the data_manager.sources.links.input_lists by default, if other sources (such as git-based documentation or pages under sso) want to be included they must be included using the --sources flag and in the configuration file. Example output a2rchi create --name my-a2rchi --config examples/deployments/basic-gpu/config.yaml --podman --env-file .secrets.env --services chatbot --gpu-ids all Starting A2RCHI deployment process... [a2rchi] Creating deployment 'my-a2rchi' with services: chatbot [a2rchi] Auto-enabling dependencies: postgres, chromadb [a2rchi] Configuration validated successfully [a2rchi] You are using an embedding model from HuggingFace; make sure to include a HuggingFace token if required for usage, it won't be explicitly enforced [a2rchi] Required secrets validated: PG_PASSWORD [a2rchi] Volume 'a2rchi-pg-my-a2rchi' already exists. No action needed. [a2rchi] Volume 'a2rchi-my-a2rchi' already exists. No action needed. [a2rchi] Starting compose deployment from /path/to/my/.a2rchi/a2rchi-my-a2rchi [a2rchi] Using compose file: /path/to/my/.a2rchi/a2rchi-my-a2rchi/compose.yaml [a2rchi] (This might take a minute...) [a2rchi] Deployment started successfully A2RCHI deployment 'my-a2rchi' created successfully! Services running: chatbot, postgres, chromadb [a2rchi] Chatbot: http://localhost:7861 The first deployment builds the container images from scratch (which may take a few minutes). Subsequent deployments reuse the images and complete much faster (roughly a minute). Tip: Having issues? Run the command with -v 4 to enable DEBUG-level logging. A note about multiple configurations When multiple configuration files are passed, their services sections must remain consistent, otherwise the deployment fails. The current use cases for multiple configurations include swapping pipelines/prompts dynamically via the chat app and maintaining separate benchmarking configurations. Verifying a deployment List running deployments with: a2rchi list-deployments You should see output similar to: Existing deployments: (Additional details will follow for each deployment.)","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"Deploy your first instance of A2RCHI and walk through the important concepts.","title":"Quickstart"},{"location":"quickstart/#sources-and-services","text":"A2RCHI can ingest data from a variety of sources and supports several services . List them with the CLI command below and decide which ones you want to use so that we can configure them. a2rchi list-services Example output: Available A2RCHI services: Application Services: chatbot Interactive chat interface for users to communicate with the AI agent grafana Monitoring dashboard for system and LLM performance metrics uploader Admin interface for uploading and managing documents grader Automated grading service for assignments with web interface Integration Services: piazza Integration service for Piazza posts and Slack notifications mattermost Integration service for Mattermost channels redmine-mailer Email processing and Cleo/Redmine ticket management Data Sources: git Git repository scraping for MkDocs-based documentation jira Jira issue tracking integration redmine Redmine ticket integration sso SSO-backed web crawling See the User Guide for detailed information about each service and source.","title":"Sources and Services"},{"location":"quickstart/#pipelines","text":"A2RCHI supports several pipelines\u2014pre-defined sequences of operations that process user inputs and generate responses. Each service supports a subset of pipelines (see the User Guide for details). An example pipeline is QAPipeline , a question-answering pipeline that takes a user's question, retrieves relevant documents from the vector store, and generates an answer using a language model. You specify which pipelines should be available in the configuration file.","title":"Pipelines"},{"location":"quickstart/#configuration","text":"Once you have chosen the services, sources, and pipelines you want to use, create a configuration file that specifies their settings. You can start from one of the example configuration files under examples/deployments/ , or create your own from scratch. This file sets parameters; the selected services and sources are determined at deployment time. Important: The configuration file follows the format of src/cli/templates/base-config.yaml . Any fields not specified in your configuration will be populated with the defaults from this template. Example configuration ( examples/deployments/basic-gpu/config.yaml ) for the chatbot service using QAPipeline with a local VLLM model: name: my_a2rchi data_manager: sources: links: visible: true # include scraped pages in the chat citations input_lists: - examples/deployments/basic-gpu/miscellanea.list embedding_name: HuggingFaceEmbeddings chunk_size: 1000 a2rchi: pipelines: - QAPipeline pipeline_map: QAPipeline: prompts: required: condense_prompt: examples/deployments/basic-gpu/condense.prompt chat_prompt: examples/deployments/basic-gpu/qa.prompt models: required: chat_model: VLLM condense_model: VLLM model_class_map: VLLM: kwargs: base_model: deepseek-ai/DeepSeek-R1-Distill-Qwen-1.5B services: chat_app: trained_on: \"My data\" hostname: \"<your-hostname>\" chromadb: chromadb_host: localhost Explanation of configuration parameters - `name`: Name of your A2RCHI deployment. - `data_manager`: Settings related to data ingestion and the vector store. - `sources.links.input_lists`: Lists of URLs to seed the deployment. - `sources. .visible`: Controls whether content from a given source should be surfaced to end users (defaults to `true`). - `embedding_name`: Embedding model used for vectorization. - `chunk_size`: Controls how documents are split prior to embedding. - `a2rchi`: Core pipeline settings. - `pipelines`: Pipelines to use (e.g., `QAPipeline`). - `pipeline_map`: Configuration for each pipeline, including prompts and models. - `model_class_map`: Mapping of model names to their classes and parameters. - `services`: Settings for individual services/interfaces. - `chat_app`: Chat interface configuration, including hostname and descriptive metadata. - `chromadb`: Connection details for the vector store container.","title":"Configuration"},{"location":"quickstart/#secrets","text":"Secrets are sensitive values (passwords, API keys, etc.) that should not be stored directly in code or configuration files. Store them in a single .env file on your filesystem. Minimal deployments (chatbot with open-source LLM and embeddings) require: PG_PASSWORD : password used to secure the database. Create the secrets file with: echo \"PG_PASSWORD=my_strong_password\" > ~/.secrets.env If you are not using open-source models, supply the relevant API credentials: OPENAI_API_KEY : OpenAI API key. ANTHROPIC_API_KEY : Anthropic API key. HUGGINGFACEHUB_API_TOKEN : HuggingFace access token (for private models or embeddings). Other services may require additional secrets; see the User Guide for details.","title":"Secrets"},{"location":"quickstart/#creating-an-a2rchi-deployment","text":"Create your deployment with the CLI: a2rchi create --name my-a2rchi --config examples/deployments/basic-gpu/config.yaml --podman --env-file .secrets.env --services chatbot --gpu-ids all This command specifies: --name : Deployment name. --config : Path to the configuration file. --podman : Use Podman for container management ( docker is the default). --env-file : Path to the secrets file. --services : Services to deploy (only the chatbot service in this example but others can be included separated by commas). Note that this command will create a deployment using only the link sources specified in the data_manager.sources.links.input_lists by default, if other sources (such as git-based documentation or pages under sso) want to be included they must be included using the --sources flag and in the configuration file. Example output a2rchi create --name my-a2rchi --config examples/deployments/basic-gpu/config.yaml --podman --env-file .secrets.env --services chatbot --gpu-ids all Starting A2RCHI deployment process... [a2rchi] Creating deployment 'my-a2rchi' with services: chatbot [a2rchi] Auto-enabling dependencies: postgres, chromadb [a2rchi] Configuration validated successfully [a2rchi] You are using an embedding model from HuggingFace; make sure to include a HuggingFace token if required for usage, it won't be explicitly enforced [a2rchi] Required secrets validated: PG_PASSWORD [a2rchi] Volume 'a2rchi-pg-my-a2rchi' already exists. No action needed. [a2rchi] Volume 'a2rchi-my-a2rchi' already exists. No action needed. [a2rchi] Starting compose deployment from /path/to/my/.a2rchi/a2rchi-my-a2rchi [a2rchi] Using compose file: /path/to/my/.a2rchi/a2rchi-my-a2rchi/compose.yaml [a2rchi] (This might take a minute...) [a2rchi] Deployment started successfully A2RCHI deployment 'my-a2rchi' created successfully! Services running: chatbot, postgres, chromadb [a2rchi] Chatbot: http://localhost:7861 The first deployment builds the container images from scratch (which may take a few minutes). Subsequent deployments reuse the images and complete much faster (roughly a minute). Tip: Having issues? Run the command with -v 4 to enable DEBUG-level logging.","title":"Creating an A2RCHI Deployment"},{"location":"quickstart/#a-note-about-multiple-configurations","text":"When multiple configuration files are passed, their services sections must remain consistent, otherwise the deployment fails. The current use cases for multiple configurations include swapping pipelines/prompts dynamically via the chat app and maintaining separate benchmarking configurations.","title":"A note about multiple configurations"},{"location":"quickstart/#verifying-a-deployment","text":"List running deployments with: a2rchi list-deployments You should see output similar to: Existing deployments: (Additional details will follow for each deployment.)","title":"Verifying a deployment"},{"location":"user_guide/","text":"User Guide Overview A2RCHI supports various data sources as easy ways to ingest your data into the vector store databased used for document retrieval. These include: Links lists (even behind SSO) : automatically scrape and ingest documents from a list of URLs Git scraping : git mkdocs repositories Ticketing systems : JIRA, Redmine, Piazza Local documents Additionally, A2RCHI supports various interfaces/services , which are applications that interact with the RAG system. These include: Chat interface : a web-based chat application Piazza integration : read posts from Piazza and post draft responses to a Slack channel Cleo/Redmine integration : read emails and create tickets in Redmine Mattermost integration : read posts from Mattermost and post draft responses to a Mattermost channel Grafana monitoring dashboard : monitor system and LLM performance metrics Document uploader : web interface for uploading and managing documents Grader : automated grading service for assignments with web interface Both data sources and interfaces/services are enabled via flags to the a2rchi create command, a2rchi create [...] --services=chatbot,piazza,... --sources jira,redmine,... The parameters of the services and sources are configured via the configuration file. See below for more details. We support various pipelines which are pre-defined sequences of operations that process user inputs and generate responses. Each service may support a given pipeline. See the Services and Pipelines sections below for more details. For each pipeline, you can use different models, retrievers, and prompts for different steps of the pipeline. We support various models for both embeddings and LLMs, which can be run locally or accessed via APIs. See the Models section below for more details. Both pipelines and models are configured via the configuration file. Finally, we support various retrievers and embedding techniques for document retrieval. These are configured via the configuration file. See the Vector Store section below for more details. Optional command line options In addition to the required --name , --config/--config-dir , --env-file , and --services arguments, the a2rchi create command accepts several useful flags: --podman : Run the deployment with Podman instead of Docker. --sources / -src : Enable additional ingestion sources ( git , sso , jira , redmine , ...). Provide a comma-separated list. --gpu-ids : Mount specific GPUs ( --gpu-ids all or --gpu-ids 0,1 ). The legacy --gpu flag still works but maps to all . --tag : Override the local image tag (defaults to 2000 ). Handy when building multiple configurations side-by-side. --hostmode : Use host networking for all services. --verbosity / -v : Control CLI logging level (0 = quiet, 4 = debug). --force / --dry-run : Force recreation of an existing deployment and/or show what would happen without actually deploying. You can inspect the available services and sources, together with descriptions, using a2rchi list-services . GPU helpers GPU access requires the NVIDIA drivers plus the NVIDIA Container Toolkit. After installing the toolkit, generate CDI entries (for Podman) with sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml and confirm with nvidia-ctk cdi list . Docker users should run sudo nvidia-ctk runtime configure --runtime=docker . Data Sources These are the different ways to ingest data into the vector store used for document retrieval. Web Link Lists A web link list is a simple text file containing a list of URLs, one per line. A2RCHI will fetch the content from each URL and add it to the vector store, using the Scraper class. Configuration You can define which lists of links A2RCHI will ingest in the configuration file as follows: data_manager: sources: links: input_lists: # REQUIRED - miscellanea.list # list of websites with relevant info - [...other lists...] Each list should be a simple text file containing one URL per line, e.g., https://example.com/page1 https://example.com/page2 [...] In the case that some of the links are behind a Single Sign-On (SSO) system, enable the SSO source in your configuration and specify the collector class: data_manager: sources: sso: enabled: true sso_class: CERNSSOScraper # or whichever class is appropriate sso_class_map: CERNSSOScraper: kwargs: headless: true max_depth: 2 Then, run a2rchi create ... --sources sso to activate the SSO collector. You can customise the HTTP scraper behaviour (for example, to avoid SSL verification warnings): data_manager: sources: links: scraper: reset_data: true verify_urls: false enable_warnings: false Secrets If you are using SSO, depending on the class, you may need to provide your login credentials in a secrets file as follows: SSO_USERNAME=username SSO_PASSWORD=password Then, make sure that the links you provide in the .list file(s) start with sso- , e.g., sso-https://example.com/protected/page Running Link scraping is automatically enabled in A2RCHI, you don't need to add any arguments to the create command unless the links are sso protected. Git scraping In some cases, the RAG input may be documentations based on MKDocs git repositories. Instead of scraping these sites as regular HTML sites you can obtain the relevant content using the GitScraper class. Configuration To configure it, enable the git source in the configuration file: data_manager: sources: git: enabled: true In the input lists, make sure to prepend git- to the URL of the repositories you are interested in scraping. git-https://github.com/example/mkdocs/documentation.git Secrets You will need to provide a git username and token in the secrets file, GIT_USERNAME=your_username GIT_TOKEN=your_token Running Enable the git source during deployment with --sources git . JIRA The JIRA integration allows A2RCHI to fetch issues and comments from specified JIRA projects and add them to the vector store, using the JiraClient class. Configuration Select which projects to scrape in the configuration file: data_manager: sources: jira: url: https://jira.example.com projects: - PROJECT_KEY anonymize_data: true You can further customise anonymisation via the global anonymiser settings. data_manager: utils: anonymizer: nlp_model: en_core_web_sm excluded_words: - Example greeting_patterns: - '^(hi|hello|hey|greetings|dear)\\b' signoff_patterns: - '\\b(regards|sincerely|best regards|cheers|thank you)\\b' email_pattern: '[\\w\\.-]+@[\\w\\.-]+\\.\\w+' username_pattern: '\\[~[^\\]]+\\]' The anonymizer will remove names, emails, usernames, greetings, signoffs, and any other words you specify from the fetched data. This is useful if you want to avoid having personal information in the vector store. Secrets A personal access token (PAT) is required to authenticate and authorize with JIRA. Add JIRA_PAT=<token> to your .env file before deploying with --sources jira . Running Enable the source at deploy time with: a2rchi create [...] --services=chatbot --sources jira Adding Documents and the Uploader Interface Adding Documents There are two main ways to add documents to A2RCHI's vector database. They are: Manually adding files while the service is running via the uploader GUI Directly copying files into the container These methods are outlined below. Manual Uploader In order to upload documents while A2RCHI is running via an easily accessible GUI, enable the uploader service when creating the deployment: a2rchi create [...] --services=chatbot,uploader The exact port may vary based on configuration (default external port is 5003 ). A quick podman ps or docker ps will show which port is exposed. In order to access the manager, you must first create an admin account. Grab the container ID with podman ps / docker ps and then enter the container: docker exec -it <CONTAINER-ID> bash Run the bundled helper: python -u src/bin/service_create_account.py from the /root/A2RCHI directory inside the container. This script will guide you through creating an account; never reuse sensitive passwords here. Once you have created an account, visit the outgoing port of the data manager docker service and then log in. The GUI will then allow you to upload documents while A2RCHI is still running. Note that it may take a few minutes for all the documents to upload. Directly copying files to the container The documents used for RAG live in the chat container at /root/data/<directory>/<files> . Thus, in a pinch, you can docker/podman cp a file at this directory level, e.g., podman/docker cp myfile.pdf <container name or ID>:/root/data/<new_dir>/ . If you need to make a new directory in the container, you can do podman exec -it <container name or ID> mkdir /root/data/<new_dir> . Redmine Use the Redmine source to ingest solved tickets (question/answer pairs) into the vector store. Configuration data_manager: sources: redmine: url: https://redmine.example.com project: my-project anonymize_data: true Secrets Add the following to your .env file: REDMINE_USER=... REDMINE_PW=... Running Enable the source at deploy time with: a2rchi create [...] --services=chatbot --sources redmine To automate email replies, also enable the redmine-mailer service (see the Services section below). Interfaces/Services These are the different apps that A2RCHI supports, which allow you to interact with the AI pipelines. Piazza Interface Set up A2RCHI to read posts from your Piazza forum and post draft responses to a specified Slack channel. To do this, a Piazza login (email and password) is required, plus the network ID of your Piazza channel, and lastly, a Webhook for the slack channel A2RCHI will post to. See below for a step-by-step description of this. Go to https://api.slack.com/apps and sign in to workspace where you will eventually want A2RCHI to post to (note doing this in a business workspace like the MIT one will require approval of the app/bot). Click 'Create New App', and then 'From scratch'. Name your app and again select the correct workspace. Then hit 'Create App' Now you have your app, and there are a few things to configure before you can launch A2RCHI: Go to Incoming Webhooks under Features, and toggle it on. Click 'Add New Webhook', and select the channel you want A2RCHI to post to. Now, copy the 'Webhook URL' and paste it into the secrets file, and handle it like any other secret! Configuration Beyond standard required configuration fields, the network ID of the Piazza channel is required (see below for an example config). You can get the network ID by simply navigating to the class homepage, and grabbing the sequence that follows 'https://piazza.com/class/'. For example, the 8.01 Fall 2024 homepage is: 'https://piazza.com/class/m0g3v0ahsqm2lg'. The network ID is thus 'm0g3v0ahsqm2lg'. Example minimal config for the Piazza interface: name: bare_minimum_configuration #REQUIRED data_manager: sources: links: input_lists: - class_info.list # class info links a2rchi: [... a2rchi config ...] services: piazza: network_id: <your Piazza network ID here> # REQUIRED chat_app: trained_on: \"Your class materials\" # REQUIRED Secrets The necessary secrets for deploying the Piazza service are the following: PIAZZA_EMAIL=... PIAZZA_PASSWORD=... SLACK_WEBHOOK=... The Slack webhook secret is described above. The Piazza email and password should be those of one of the class instructors. Remember to put this information in files named following what is written above. Running To run the Piazza service, simply add the piazza flag. For example: a2rchi create [...] --services=chatbot,piazza Redmine/Mailbox Interface A2RCHI will read all new tickets in a Redmine project, and draft a response as a comment to the ticket. Once the ticket is updated to the \"Resolved\" status by an admin, A2RCHI will send the response as an email to the user who opened the ticket. The admin can modify A2RCHI's response before sending it out. Configuration services: redmine_mailbox: url: https://redmine.example.com project: my-project redmine_update_time: 10 mailbox_update_time: 10 answer_tag: \"-- A2RCHI -- Resolving email was sent\" Secrets Add the following secrets to your .env file: IMAP_USER=... IMAP_PW=... REDMINE_USER=... REDMINE_PW=... SENDER_SERVER=... SENDER_PORT=587 SENDER_REPLYTO=... SENDER_USER=... SENDER_PW=... Running a2rchi create [...] --services=chatbot,redmine-mailer Mattermost Interface Set up A2RCHI to read posts from your Mattermost forum and post draft responses to a specified Mattermost channel. Configuration services: mattermost: update_time: 60 Secrets You need to specify a webhook, access token, and channel identifiers: MATTERMOST_WEBHOOK=... MATTERMOST_PAK=... MATTERMOST_CHANNEL_ID_READ=... MATTERMOST_CHANNEL_ID_WRITE=... Running To run the Mattermost service, include it when selecting services. For example: a2rchi create [...] --services=chatbot,mattermost Grafana Interface Monitor the performance of your A2RCHI instance with the Grafana interface. This service provides a web-based dashboard to visualize various metrics related to system performance, LLM usage, and more. Note, if you are deploying a version of A2RCHI you have already used (i.e., you haven't removed the images/volumes for a given --name ), the postgres will have already been created without the Grafana user created, and it will not work, so make sure to deploy a fresh instance. Configuration services: grafana: external_port: 3000 Secrets Grafana shares the Postgres database with other services, so you need both the database password and a Grafana-specific password: PG_PASSWORD=<your_database_password> GRAFANA_PG_PASSWORD=<grafana_db_password> Running Deploy Grafana alongside your other services: a2rchi create [...] --services=chatbot,grafana and you should see something like this CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d27482864238 localhost/chromadb-gtesting2:2000 uvicorn chromadb.... 9 minutes ago Up 9 minutes (healthy) 0.0.0.0:8000->8000/tcp, 8000/tcp chromadb-gtesting2 87f1c7289d29 docker.io/library/postgres:16 postgres 9 minutes ago Up 9 minutes (healthy) 5432/tcp postgres-gtesting2 40130e8e23de docker.io/library/grafana-gtesting2:2000 9 minutes ago Up 9 minutes 0.0.0.0:3000->3000/tcp, 3000/tcp grafana-gtesting2 d6ce8a149439 localhost/chat-gtesting2:2000 python -u a2rchi/... 9 minutes ago Up 9 minutes 0.0.0.0:7861->7861/tcp chat-gtesting2 where the grafana interface is accessible at your-hostname:3000 . To change the external port from 3000 , you can do this in the config at services.grafana.external_port . The default login and password are both \"admin\", which you will be prompted to change should you want to after first logging in. Navigate to the A2RCHI dashboard from the home page by going to the menu > Dashboards > A2RCHI > A2RCHI Usage. Note, your-hostname here is the just name of the machine. Grafana uses its default configuration which is localhost but unlike the chat interface, there are no APIs where we template with a selected hostname, so the container networking handles this nicely. Pro tip: once at the web interface, for the \"Recent Conversation Messages (Clean Text + Link)\" panel, click the three little dots in the top right hand corner of the panel, click \"Edit\", and on the right, go to e.g., \"Override 4\" (should have Fields with name: clean text, also Override 7 for context column) and override property \"Cell options > Cell value inspect\". This will allow you to expand the text boxes with messages longer than can fit. Make sure you click apply to keep the changes. Pro tip 2: If you want to download all of the information from any panel as a CSV, go to the same three dots and click \"Inspect\", and you should see the option. Grader Interface Interface to launch a website which for a provided solution and rubric (and a couple of other things detailed below), will grade scanned images of a handwritten solution for the specified problem(s). Nota bene: this is not yet fully generalized and \"service\" ready, but instead for testing grading pipelines and a base off of which to build a potential grading app. Requirements To launch the service the following files are required: users.csv . This file is .csv file that contains two columns: \"MIT email\" and \"Unique code\", e.g.: MIT email,Unique code username@mit.edu,222 For now, the system requires the emails to be in the MIT domain, namely, contain \"@mit.edu\". TODO: make this an argument that is passed (e.g., school/email domain) solution_with_rubric_*.txt . These are .txt files that contain the problem solution followed by the rubric. The naming of the files should follow exactly, where the * is the problem number. There should be one of these files for every problem you want the app to be able to grade. The top of the file should be the problem name with a line of dashes (\"-\") below, e.g.: Anti-Helmholtz Coils --------------------------------------------------- These files should live in a directory which you will pass to the config, and A2RCHI will handle the rest. admin_password.txt . This file will be passed as a secret and be the admin code to login in to the page where you can reset attempts for students. Secrets The only grading specific secret is the admin password, which like shown above, should be put in the following file ADMIN_PASSWORD=your_password Then it behaves like any other secret. Configuration The required fields in the configuration file are different from the rest of the A2RCHI services. Below is an example: name: grading_test # REQUIRED a2rchi: pipelines: - GradingPipeline pipeline_map: GradingPipeline: prompts: required: final_grade_prompt: final_grade.prompt models: required: final_grade_model: OllamaInterface ImageProcessingPipeline: prompts: required: image_processing_prompt: image_processing.prompt models: required: image_processing_model: OllamaInterface services: chat_app: trained_on: \"rubrics, class info, etc.\" # REQUIRED grader_app: num_problems: 1 # REQUIRED local_rubric_dir: ~/grading/my_rubrics # REQUIRED local_users_csv_dir: ~/grading/logins # REQUIRED data_manager: [...] name -- The name of your configuration (required). a2rchi.pipelines -- List of pipelines to use (e.g., GradingPipeline , ImageProcessingPipeline ). a2rchi.pipeline_map -- Mapping of pipelines to their required prompts and models. a2rchi.pipeline_map.GradingPipeline.prompts.required.final_grade_prompt -- Path to the grading prompt file for evaluating student solutions. a2rchi.pipeline_map.GradingPipeline.models.required.final_grade_model -- Model class for grading (e.g., OllamaInterface , HuggingFaceOpenLLM ). a2rchi.pipeline_map.ImageProcessingPipeline.prompts.required.image_processing_prompt -- Path to the prompt file for image processing. a2rchi.pipeline_map.ImageProcessingPipeline.models.required.image_processing_model -- Model class for image processing (e.g., OllamaInterface , HuggingFaceImageLLM ). services.chat_app.trained_on -- A brief description of the data or materials A2RCHI is trained on (required). services.grader_app.num_problems -- Number of problems the grading service should expect (must match the number of rubric files). services.grader_app.local_rubric_dir -- Directory containing the solution_with_rubric_*.txt files. services.grader_app.local_users_csv_dir -- Directory containing the users.csv file. Running a2rchi create [...] --services=grader Models Models are either: Hosted locally, either via VLLM or HuggingFace transformers. Accessed via an API, e.g., OpenAI, Anthropic, etc. Accessed via an Ollama server instance. Local Models To use a local model, specify one of the local model classes in models.py : HuggingFaceOpenLLM HuggingFaceImageLLM VLLM Models via APIs We support the following model classes in models.py for models accessed via APIs: OpenAILLM AnthropicLLM Ollama In order to use an Ollama server instance for the chatbot, it is possible to specify OllamaInterface for the model name. To then correctly use models on the Ollama server, in the keyword args, specify both the url of the server and the name of a model hosted on the server. a2rchi: model_class_map: OllamaInterface: kwargs: base_model: \"gemma3\" # example url: \"url-for-server\" In this case, the gemma3 model is hosted on the Ollama server at url-for-server . You can check which models are hosted on your server by going to url-for-server/models . Vector Store The vector store is a database that stores document embeddings, enabling semantic and/or lexical search over your knowledge base. A2RCHI uses ChromaDB as the vector store backend to index and retrieve relevant documents based on similarity to user queries. Configuration Vector store settings are configured under the data_manager section: data_manager: collection_name: default_collection embedding_name: OpenAIEmbeddings chunk_size: 1000 chunk_overlap: 0 reset_collection: true num_documents_to_retrieve: 5 distance_metric: cosine Core Settings collection_name : Name of the ChromaDB collection. Default: default_collection chunk_size : Maximum size of text chunks (in characters) when splitting documents. Default: 1000 chunk_overlap : Number of overlapping characters between consecutive chunks. Default: 0 reset_collection : If true , deletes and recreates the collection on startup. Default: true num_documents_to_retrieve : Number of relevant document chunks to retrieve for each query. Default: 5 Distance Metrics The distance_metric determines how similarity is calculated between embeddings: cosine : Cosine similarity (default) - measures the angle between vectors l2 : Euclidean distance - measures straight-line distance ip : Inner product - measures dot product similarity data_manager: distance_metric: cosine # Options: cosine, l2, ip Embedding Models Embeddings convert text into numerical vectors. A2RCHI supports multiple embedding providers: OpenAI Embeddings data_manager: embedding_name: OpenAIEmbeddings embedding_class_map: OpenAIEmbeddings: class: OpenAIEmbeddings kwargs: model: text-embedding-3-small similarity_score_reference: 10 HuggingFace Embeddings data_manager: embedding_name: HuggingFaceEmbeddings embedding_class_map: HuggingFaceEmbeddings: class: HuggingFaceEmbeddings kwargs: model_name: sentence-transformers/all-MiniLM-L6-v2 model_kwargs: device: cpu encode_kwargs: normalize_embeddings: true similarity_score_reference: 10 query_embedding_instructions: null Supported Document Formats The vector store can process the following file types: Text files : .txt , .C Markdown : .md Python : .py HTML : .html PDF : .pdf Documents are automatically loaded with the appropriate parser based on file extension. Document Synchronization A2RCHI automatically synchronizes your data directory with the vector store: Adding documents : New files in the data directory are automatically chunked, embedded, and added to the collection Removing documents : Files deleted from the data directory are removed from the collection Source tracking : Each ingested artifact is recorded in the unified index.yaml file as <resource-hash>: <relative file path> inside the data directory Hybrid Search Combine semantic search with keyword-based BM25 search for improved retrieval: data_manager: use_hybrid_search: true bm25_weight: 0.6 semantic_weight: 0.4 bm25: k1: 0.5 b: 0.75 use_hybrid_search : Enable hybrid search combining BM25 and semantic similarity. Default: false bm25_weight : Weight for BM25 keyword scores. Default: 0.6 semantic_weight : Weight for semantic similarity scores. Default: 0.4 bm25.k1 : BM25 term frequency saturation parameter. Default: 0.5 bm25.b : BM25 document length normalization parameter. Default: 0.75 Stemming By specifying the stemming option within your configuration, stemming functionality for the documents in A2RCHI will be enabled. By doing so, documents inserted into the retrieval pipeline, as well as the query that is matched with them, will be stemmed and simplified for faster and more accurate lookup. data_manager: stemming: enabled: true When enabled, both documents and queries are processed using the Porter Stemmer algorithm to reduce words to their root forms (e.g., \"running\" \u2192 \"run\"), improving matching accuracy. ChromaDB Backend A2RCHI supports both local and remote ChromaDB instances: Local (Persistent) services: chromadb: local_vstore_path: /path/to/vectorstore Remote (HTTP Client) services: chromadb: use_HTTP_chromadb_client: true chromadb_host: localhost chromadb_port: 8000 Benchmarking Required inputs and configuration A2RCHI has benchmarking functionality provided by the evaluate CLI command. Before beginning, provide your list of questions in JSON format as follows: [ { \"question\": \"\", \"link\": \"\", \"answer\": \"\" }, ... { \"question\": \"\", \"link\": \"\", \"answer\": \"\" } ] Then within all of the yaml configuration files that you wish to test, add a configuration for your benchmarking script, which looks like the following: services: benchmarking: queries_path: examples/benchmarking/queries.json out_dir: bench_out modes: - \"RAGAS\" - \"LINKS\" Finally, before you run the command ensure out_dir , the output directory, both exists on your system and that the path is correctly specified so that results can show up inside of it. To run the benchmarking script simply run the following: Running a2rchi evaluate -n <name> -e <env_file> -cd <configs_directory> <optionally use -c <file1>,<file2>, ...> <OPTIONS> Currently, the benchmarking supports both a RAGAS runtime and a LINKS runtime, users can specify which modes they want to run by using the modes section. By default, both are enabled. The LINKS mode will generate outputs from your A2RCHI instance as specified in your other configurations and evaluate it based on if the top k documents retrieved include information from the provided link answer. Note however that this still might mean that the chunks provided as context might still be incorrect, even if they are from the same source link. Additional options The RAGAS mode will use the Ragas RAG evaluator module to return numerical values judging by 4 of their provided metrics: answer_relevancy , faithfulness , context precision , and context relevancy . More information about these metrics can be found on their website at: https://docs.ragas.io/en/stable/concepts/metrics/. Note that ragas will by default use OpenAI to evaluate your llm responses and ragging pipeline contexts. To change this, it is possible to specify using other providers such as Anthropic, Ollama, and HuggingFace for your LLM evaluator, as well as HuggingFace for the embeddings. To do so simply specify in the configuration as follows: services: benchmarking: queries_path: examples/benchmarking/queries.json out_dir: bench_out modes: - \"RAGAS\" - \"LINKS\" mode_settings: ragas_settings: provider: <provider name> # can be one of OpenAI, HuggingFace, Ollama, and Anthropic evaluation_model_settings: model_name: <model name> # ensure this lines up with the langchain API name for your chosen model and provider base_url: <url> # address to your running Ollama server should you have chosen the Ollama provider embedding_model: <embedding provider> # OpenAI or HuggingFace You might also want to adjust the timeout setting, which is the upper limit on how long the Ragas evaluation takes on a single QA pair, or the batch_size , which determines how many QA pairs to evaluate at once, which you might want to adjust, e.g., based on hardware constraints, as Ragas doesn't pay great attention to that. The corresponding configuration options are similarly set for the benchmarking services, as follows: services: benchmarking: timeout: <time in seconds> # default is 180 batch_size: <desired batch size> # no default setting, set by Ragas... To later examine your data, there is a folder called plots in the base directory which contains some plotting functions and an ipynotebook with some basic usage examples. This is useful to play around with the results of the benchmarking, we will soon also have instead dedicated scripts to produce the plots of interest. Other Some useful additional features supported by the framework. Add ChromaDB Document Management API Endpoints Debugging ChromaDB endpoints Debugging REST API endpoints to the A2RCHI chat application for programmatic access to the ChromaDB vector database can be exposed with the following configuration change. To enable the ChromaDB endpoints, add the following to your config file under services.chat_app : services: chat_app: # ... other config options ... enable_debug_chroma_endpoints: true # Default: false ChromaDB Endpoints Info # /api/list_docs (GET) Lists all documents indexed in ChromaDB with pagination support. Query Parameters: - page : Page number (1-based, default: 1) - per_page : Documents per page (default: 50, max: 500) - content_length : Content preview length (default: -1 for full content) Response: { \"pagination\": { \"page\": 1, \"per_page\": 50, \"total_documents\": 1250, \"total_pages\": 25, \"has_next\": true, \"has_prev\": false }, \"documents\": [...] } # /api/search_docs (POST) Performs semantic search on the document collection using vector similarity. Request Body: - query : Search query string (required) - n_results : Number of results (default: 5, max: 100) - content_length : Max content length (default: -1, max: 5000) - include_full_content : Include complete document content (default: false) Response: { \"query\": \"machine learning\", \"search_params\": {...}, \"documents\": [ { \"content\": \"Document content...\", \"content_length\": 1200, \"metadata\": {...}, \"similarity_score\": 0.85 } ] }","title":"User Guide"},{"location":"user_guide/#user-guide","text":"","title":"User Guide"},{"location":"user_guide/#overview","text":"A2RCHI supports various data sources as easy ways to ingest your data into the vector store databased used for document retrieval. These include: Links lists (even behind SSO) : automatically scrape and ingest documents from a list of URLs Git scraping : git mkdocs repositories Ticketing systems : JIRA, Redmine, Piazza Local documents Additionally, A2RCHI supports various interfaces/services , which are applications that interact with the RAG system. These include: Chat interface : a web-based chat application Piazza integration : read posts from Piazza and post draft responses to a Slack channel Cleo/Redmine integration : read emails and create tickets in Redmine Mattermost integration : read posts from Mattermost and post draft responses to a Mattermost channel Grafana monitoring dashboard : monitor system and LLM performance metrics Document uploader : web interface for uploading and managing documents Grader : automated grading service for assignments with web interface Both data sources and interfaces/services are enabled via flags to the a2rchi create command, a2rchi create [...] --services=chatbot,piazza,... --sources jira,redmine,... The parameters of the services and sources are configured via the configuration file. See below for more details. We support various pipelines which are pre-defined sequences of operations that process user inputs and generate responses. Each service may support a given pipeline. See the Services and Pipelines sections below for more details. For each pipeline, you can use different models, retrievers, and prompts for different steps of the pipeline. We support various models for both embeddings and LLMs, which can be run locally or accessed via APIs. See the Models section below for more details. Both pipelines and models are configured via the configuration file. Finally, we support various retrievers and embedding techniques for document retrieval. These are configured via the configuration file. See the Vector Store section below for more details.","title":"Overview"},{"location":"user_guide/#optional-command-line-options","text":"In addition to the required --name , --config/--config-dir , --env-file , and --services arguments, the a2rchi create command accepts several useful flags: --podman : Run the deployment with Podman instead of Docker. --sources / -src : Enable additional ingestion sources ( git , sso , jira , redmine , ...). Provide a comma-separated list. --gpu-ids : Mount specific GPUs ( --gpu-ids all or --gpu-ids 0,1 ). The legacy --gpu flag still works but maps to all . --tag : Override the local image tag (defaults to 2000 ). Handy when building multiple configurations side-by-side. --hostmode : Use host networking for all services. --verbosity / -v : Control CLI logging level (0 = quiet, 4 = debug). --force / --dry-run : Force recreation of an existing deployment and/or show what would happen without actually deploying. You can inspect the available services and sources, together with descriptions, using a2rchi list-services . GPU helpers GPU access requires the NVIDIA drivers plus the NVIDIA Container Toolkit. After installing the toolkit, generate CDI entries (for Podman) with sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml and confirm with nvidia-ctk cdi list . Docker users should run sudo nvidia-ctk runtime configure --runtime=docker .","title":"Optional command line options"},{"location":"user_guide/#data-sources","text":"These are the different ways to ingest data into the vector store used for document retrieval.","title":"Data Sources"},{"location":"user_guide/#web-link-lists","text":"A web link list is a simple text file containing a list of URLs, one per line. A2RCHI will fetch the content from each URL and add it to the vector store, using the Scraper class.","title":"Web Link Lists"},{"location":"user_guide/#configuration","text":"You can define which lists of links A2RCHI will ingest in the configuration file as follows: data_manager: sources: links: input_lists: # REQUIRED - miscellanea.list # list of websites with relevant info - [...other lists...] Each list should be a simple text file containing one URL per line, e.g., https://example.com/page1 https://example.com/page2 [...] In the case that some of the links are behind a Single Sign-On (SSO) system, enable the SSO source in your configuration and specify the collector class: data_manager: sources: sso: enabled: true sso_class: CERNSSOScraper # or whichever class is appropriate sso_class_map: CERNSSOScraper: kwargs: headless: true max_depth: 2 Then, run a2rchi create ... --sources sso to activate the SSO collector. You can customise the HTTP scraper behaviour (for example, to avoid SSL verification warnings): data_manager: sources: links: scraper: reset_data: true verify_urls: false enable_warnings: false","title":"Configuration"},{"location":"user_guide/#secrets","text":"If you are using SSO, depending on the class, you may need to provide your login credentials in a secrets file as follows: SSO_USERNAME=username SSO_PASSWORD=password Then, make sure that the links you provide in the .list file(s) start with sso- , e.g., sso-https://example.com/protected/page","title":"Secrets"},{"location":"user_guide/#running","text":"Link scraping is automatically enabled in A2RCHI, you don't need to add any arguments to the create command unless the links are sso protected.","title":"Running"},{"location":"user_guide/#git-scraping","text":"In some cases, the RAG input may be documentations based on MKDocs git repositories. Instead of scraping these sites as regular HTML sites you can obtain the relevant content using the GitScraper class.","title":"Git scraping"},{"location":"user_guide/#configuration_1","text":"To configure it, enable the git source in the configuration file: data_manager: sources: git: enabled: true In the input lists, make sure to prepend git- to the URL of the repositories you are interested in scraping. git-https://github.com/example/mkdocs/documentation.git","title":"Configuration"},{"location":"user_guide/#secrets_1","text":"You will need to provide a git username and token in the secrets file, GIT_USERNAME=your_username GIT_TOKEN=your_token","title":"Secrets"},{"location":"user_guide/#running_1","text":"Enable the git source during deployment with --sources git .","title":"Running"},{"location":"user_guide/#jira","text":"The JIRA integration allows A2RCHI to fetch issues and comments from specified JIRA projects and add them to the vector store, using the JiraClient class.","title":"JIRA"},{"location":"user_guide/#configuration_2","text":"Select which projects to scrape in the configuration file: data_manager: sources: jira: url: https://jira.example.com projects: - PROJECT_KEY anonymize_data: true You can further customise anonymisation via the global anonymiser settings. data_manager: utils: anonymizer: nlp_model: en_core_web_sm excluded_words: - Example greeting_patterns: - '^(hi|hello|hey|greetings|dear)\\b' signoff_patterns: - '\\b(regards|sincerely|best regards|cheers|thank you)\\b' email_pattern: '[\\w\\.-]+@[\\w\\.-]+\\.\\w+' username_pattern: '\\[~[^\\]]+\\]' The anonymizer will remove names, emails, usernames, greetings, signoffs, and any other words you specify from the fetched data. This is useful if you want to avoid having personal information in the vector store.","title":"Configuration"},{"location":"user_guide/#secrets_2","text":"A personal access token (PAT) is required to authenticate and authorize with JIRA. Add JIRA_PAT=<token> to your .env file before deploying with --sources jira .","title":"Secrets"},{"location":"user_guide/#running_2","text":"Enable the source at deploy time with: a2rchi create [...] --services=chatbot --sources jira","title":"Running"},{"location":"user_guide/#adding-documents-and-the-uploader-interface","text":"","title":"Adding Documents and the Uploader Interface"},{"location":"user_guide/#adding-documents","text":"There are two main ways to add documents to A2RCHI's vector database. They are: Manually adding files while the service is running via the uploader GUI Directly copying files into the container These methods are outlined below.","title":"Adding Documents"},{"location":"user_guide/#manual-uploader","text":"In order to upload documents while A2RCHI is running via an easily accessible GUI, enable the uploader service when creating the deployment: a2rchi create [...] --services=chatbot,uploader The exact port may vary based on configuration (default external port is 5003 ). A quick podman ps or docker ps will show which port is exposed. In order to access the manager, you must first create an admin account. Grab the container ID with podman ps / docker ps and then enter the container: docker exec -it <CONTAINER-ID> bash Run the bundled helper: python -u src/bin/service_create_account.py from the /root/A2RCHI directory inside the container. This script will guide you through creating an account; never reuse sensitive passwords here. Once you have created an account, visit the outgoing port of the data manager docker service and then log in. The GUI will then allow you to upload documents while A2RCHI is still running. Note that it may take a few minutes for all the documents to upload.","title":"Manual Uploader"},{"location":"user_guide/#directly-copying-files-to-the-container","text":"The documents used for RAG live in the chat container at /root/data/<directory>/<files> . Thus, in a pinch, you can docker/podman cp a file at this directory level, e.g., podman/docker cp myfile.pdf <container name or ID>:/root/data/<new_dir>/ . If you need to make a new directory in the container, you can do podman exec -it <container name or ID> mkdir /root/data/<new_dir> .","title":"Directly copying files to the container"},{"location":"user_guide/#redmine","text":"Use the Redmine source to ingest solved tickets (question/answer pairs) into the vector store.","title":"Redmine"},{"location":"user_guide/#configuration_3","text":"data_manager: sources: redmine: url: https://redmine.example.com project: my-project anonymize_data: true","title":"Configuration"},{"location":"user_guide/#secrets_3","text":"Add the following to your .env file: REDMINE_USER=... REDMINE_PW=...","title":"Secrets"},{"location":"user_guide/#running_3","text":"Enable the source at deploy time with: a2rchi create [...] --services=chatbot --sources redmine To automate email replies, also enable the redmine-mailer service (see the Services section below).","title":"Running"},{"location":"user_guide/#interfacesservices","text":"These are the different apps that A2RCHI supports, which allow you to interact with the AI pipelines.","title":"Interfaces/Services"},{"location":"user_guide/#piazza-interface","text":"Set up A2RCHI to read posts from your Piazza forum and post draft responses to a specified Slack channel. To do this, a Piazza login (email and password) is required, plus the network ID of your Piazza channel, and lastly, a Webhook for the slack channel A2RCHI will post to. See below for a step-by-step description of this. Go to https://api.slack.com/apps and sign in to workspace where you will eventually want A2RCHI to post to (note doing this in a business workspace like the MIT one will require approval of the app/bot). Click 'Create New App', and then 'From scratch'. Name your app and again select the correct workspace. Then hit 'Create App' Now you have your app, and there are a few things to configure before you can launch A2RCHI: Go to Incoming Webhooks under Features, and toggle it on. Click 'Add New Webhook', and select the channel you want A2RCHI to post to. Now, copy the 'Webhook URL' and paste it into the secrets file, and handle it like any other secret!","title":"Piazza Interface"},{"location":"user_guide/#configuration_4","text":"Beyond standard required configuration fields, the network ID of the Piazza channel is required (see below for an example config). You can get the network ID by simply navigating to the class homepage, and grabbing the sequence that follows 'https://piazza.com/class/'. For example, the 8.01 Fall 2024 homepage is: 'https://piazza.com/class/m0g3v0ahsqm2lg'. The network ID is thus 'm0g3v0ahsqm2lg'. Example minimal config for the Piazza interface: name: bare_minimum_configuration #REQUIRED data_manager: sources: links: input_lists: - class_info.list # class info links a2rchi: [... a2rchi config ...] services: piazza: network_id: <your Piazza network ID here> # REQUIRED chat_app: trained_on: \"Your class materials\" # REQUIRED","title":"Configuration"},{"location":"user_guide/#secrets_4","text":"The necessary secrets for deploying the Piazza service are the following: PIAZZA_EMAIL=... PIAZZA_PASSWORD=... SLACK_WEBHOOK=... The Slack webhook secret is described above. The Piazza email and password should be those of one of the class instructors. Remember to put this information in files named following what is written above.","title":"Secrets"},{"location":"user_guide/#running_4","text":"To run the Piazza service, simply add the piazza flag. For example: a2rchi create [...] --services=chatbot,piazza","title":"Running"},{"location":"user_guide/#redminemailbox-interface","text":"A2RCHI will read all new tickets in a Redmine project, and draft a response as a comment to the ticket. Once the ticket is updated to the \"Resolved\" status by an admin, A2RCHI will send the response as an email to the user who opened the ticket. The admin can modify A2RCHI's response before sending it out.","title":"Redmine/Mailbox Interface"},{"location":"user_guide/#configuration_5","text":"services: redmine_mailbox: url: https://redmine.example.com project: my-project redmine_update_time: 10 mailbox_update_time: 10 answer_tag: \"-- A2RCHI -- Resolving email was sent\"","title":"Configuration"},{"location":"user_guide/#secrets_5","text":"Add the following secrets to your .env file: IMAP_USER=... IMAP_PW=... REDMINE_USER=... REDMINE_PW=... SENDER_SERVER=... SENDER_PORT=587 SENDER_REPLYTO=... SENDER_USER=... SENDER_PW=...","title":"Secrets"},{"location":"user_guide/#running_5","text":"a2rchi create [...] --services=chatbot,redmine-mailer","title":"Running"},{"location":"user_guide/#mattermost-interface","text":"Set up A2RCHI to read posts from your Mattermost forum and post draft responses to a specified Mattermost channel.","title":"Mattermost Interface"},{"location":"user_guide/#configuration_6","text":"services: mattermost: update_time: 60","title":"Configuration"},{"location":"user_guide/#secrets_6","text":"You need to specify a webhook, access token, and channel identifiers: MATTERMOST_WEBHOOK=... MATTERMOST_PAK=... MATTERMOST_CHANNEL_ID_READ=... MATTERMOST_CHANNEL_ID_WRITE=...","title":"Secrets"},{"location":"user_guide/#running_6","text":"To run the Mattermost service, include it when selecting services. For example: a2rchi create [...] --services=chatbot,mattermost","title":"Running"},{"location":"user_guide/#grafana-interface","text":"Monitor the performance of your A2RCHI instance with the Grafana interface. This service provides a web-based dashboard to visualize various metrics related to system performance, LLM usage, and more. Note, if you are deploying a version of A2RCHI you have already used (i.e., you haven't removed the images/volumes for a given --name ), the postgres will have already been created without the Grafana user created, and it will not work, so make sure to deploy a fresh instance.","title":"Grafana Interface"},{"location":"user_guide/#configuration_7","text":"services: grafana: external_port: 3000","title":"Configuration"},{"location":"user_guide/#secrets_7","text":"Grafana shares the Postgres database with other services, so you need both the database password and a Grafana-specific password: PG_PASSWORD=<your_database_password> GRAFANA_PG_PASSWORD=<grafana_db_password>","title":"Secrets"},{"location":"user_guide/#running_7","text":"Deploy Grafana alongside your other services: a2rchi create [...] --services=chatbot,grafana and you should see something like this CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d27482864238 localhost/chromadb-gtesting2:2000 uvicorn chromadb.... 9 minutes ago Up 9 minutes (healthy) 0.0.0.0:8000->8000/tcp, 8000/tcp chromadb-gtesting2 87f1c7289d29 docker.io/library/postgres:16 postgres 9 minutes ago Up 9 minutes (healthy) 5432/tcp postgres-gtesting2 40130e8e23de docker.io/library/grafana-gtesting2:2000 9 minutes ago Up 9 minutes 0.0.0.0:3000->3000/tcp, 3000/tcp grafana-gtesting2 d6ce8a149439 localhost/chat-gtesting2:2000 python -u a2rchi/... 9 minutes ago Up 9 minutes 0.0.0.0:7861->7861/tcp chat-gtesting2 where the grafana interface is accessible at your-hostname:3000 . To change the external port from 3000 , you can do this in the config at services.grafana.external_port . The default login and password are both \"admin\", which you will be prompted to change should you want to after first logging in. Navigate to the A2RCHI dashboard from the home page by going to the menu > Dashboards > A2RCHI > A2RCHI Usage. Note, your-hostname here is the just name of the machine. Grafana uses its default configuration which is localhost but unlike the chat interface, there are no APIs where we template with a selected hostname, so the container networking handles this nicely. Pro tip: once at the web interface, for the \"Recent Conversation Messages (Clean Text + Link)\" panel, click the three little dots in the top right hand corner of the panel, click \"Edit\", and on the right, go to e.g., \"Override 4\" (should have Fields with name: clean text, also Override 7 for context column) and override property \"Cell options > Cell value inspect\". This will allow you to expand the text boxes with messages longer than can fit. Make sure you click apply to keep the changes. Pro tip 2: If you want to download all of the information from any panel as a CSV, go to the same three dots and click \"Inspect\", and you should see the option.","title":"Running"},{"location":"user_guide/#grader-interface","text":"Interface to launch a website which for a provided solution and rubric (and a couple of other things detailed below), will grade scanned images of a handwritten solution for the specified problem(s). Nota bene: this is not yet fully generalized and \"service\" ready, but instead for testing grading pipelines and a base off of which to build a potential grading app.","title":"Grader Interface"},{"location":"user_guide/#requirements","text":"To launch the service the following files are required: users.csv . This file is .csv file that contains two columns: \"MIT email\" and \"Unique code\", e.g.: MIT email,Unique code username@mit.edu,222 For now, the system requires the emails to be in the MIT domain, namely, contain \"@mit.edu\". TODO: make this an argument that is passed (e.g., school/email domain) solution_with_rubric_*.txt . These are .txt files that contain the problem solution followed by the rubric. The naming of the files should follow exactly, where the * is the problem number. There should be one of these files for every problem you want the app to be able to grade. The top of the file should be the problem name with a line of dashes (\"-\") below, e.g.: Anti-Helmholtz Coils --------------------------------------------------- These files should live in a directory which you will pass to the config, and A2RCHI will handle the rest. admin_password.txt . This file will be passed as a secret and be the admin code to login in to the page where you can reset attempts for students.","title":"Requirements"},{"location":"user_guide/#secrets_8","text":"The only grading specific secret is the admin password, which like shown above, should be put in the following file ADMIN_PASSWORD=your_password Then it behaves like any other secret.","title":"Secrets"},{"location":"user_guide/#configuration_8","text":"The required fields in the configuration file are different from the rest of the A2RCHI services. Below is an example: name: grading_test # REQUIRED a2rchi: pipelines: - GradingPipeline pipeline_map: GradingPipeline: prompts: required: final_grade_prompt: final_grade.prompt models: required: final_grade_model: OllamaInterface ImageProcessingPipeline: prompts: required: image_processing_prompt: image_processing.prompt models: required: image_processing_model: OllamaInterface services: chat_app: trained_on: \"rubrics, class info, etc.\" # REQUIRED grader_app: num_problems: 1 # REQUIRED local_rubric_dir: ~/grading/my_rubrics # REQUIRED local_users_csv_dir: ~/grading/logins # REQUIRED data_manager: [...] name -- The name of your configuration (required). a2rchi.pipelines -- List of pipelines to use (e.g., GradingPipeline , ImageProcessingPipeline ). a2rchi.pipeline_map -- Mapping of pipelines to their required prompts and models. a2rchi.pipeline_map.GradingPipeline.prompts.required.final_grade_prompt -- Path to the grading prompt file for evaluating student solutions. a2rchi.pipeline_map.GradingPipeline.models.required.final_grade_model -- Model class for grading (e.g., OllamaInterface , HuggingFaceOpenLLM ). a2rchi.pipeline_map.ImageProcessingPipeline.prompts.required.image_processing_prompt -- Path to the prompt file for image processing. a2rchi.pipeline_map.ImageProcessingPipeline.models.required.image_processing_model -- Model class for image processing (e.g., OllamaInterface , HuggingFaceImageLLM ). services.chat_app.trained_on -- A brief description of the data or materials A2RCHI is trained on (required). services.grader_app.num_problems -- Number of problems the grading service should expect (must match the number of rubric files). services.grader_app.local_rubric_dir -- Directory containing the solution_with_rubric_*.txt files. services.grader_app.local_users_csv_dir -- Directory containing the users.csv file.","title":"Configuration"},{"location":"user_guide/#running_8","text":"a2rchi create [...] --services=grader","title":"Running"},{"location":"user_guide/#models","text":"Models are either: Hosted locally, either via VLLM or HuggingFace transformers. Accessed via an API, e.g., OpenAI, Anthropic, etc. Accessed via an Ollama server instance.","title":"Models"},{"location":"user_guide/#local-models","text":"To use a local model, specify one of the local model classes in models.py : HuggingFaceOpenLLM HuggingFaceImageLLM VLLM","title":"Local Models"},{"location":"user_guide/#models-via-apis","text":"We support the following model classes in models.py for models accessed via APIs: OpenAILLM AnthropicLLM","title":"Models via APIs"},{"location":"user_guide/#ollama","text":"In order to use an Ollama server instance for the chatbot, it is possible to specify OllamaInterface for the model name. To then correctly use models on the Ollama server, in the keyword args, specify both the url of the server and the name of a model hosted on the server. a2rchi: model_class_map: OllamaInterface: kwargs: base_model: \"gemma3\" # example url: \"url-for-server\" In this case, the gemma3 model is hosted on the Ollama server at url-for-server . You can check which models are hosted on your server by going to url-for-server/models .","title":"Ollama"},{"location":"user_guide/#vector-store","text":"The vector store is a database that stores document embeddings, enabling semantic and/or lexical search over your knowledge base. A2RCHI uses ChromaDB as the vector store backend to index and retrieve relevant documents based on similarity to user queries.","title":"Vector Store"},{"location":"user_guide/#configuration_9","text":"Vector store settings are configured under the data_manager section: data_manager: collection_name: default_collection embedding_name: OpenAIEmbeddings chunk_size: 1000 chunk_overlap: 0 reset_collection: true num_documents_to_retrieve: 5 distance_metric: cosine","title":"Configuration"},{"location":"user_guide/#core-settings","text":"collection_name : Name of the ChromaDB collection. Default: default_collection chunk_size : Maximum size of text chunks (in characters) when splitting documents. Default: 1000 chunk_overlap : Number of overlapping characters between consecutive chunks. Default: 0 reset_collection : If true , deletes and recreates the collection on startup. Default: true num_documents_to_retrieve : Number of relevant document chunks to retrieve for each query. Default: 5","title":"Core Settings"},{"location":"user_guide/#distance-metrics","text":"The distance_metric determines how similarity is calculated between embeddings: cosine : Cosine similarity (default) - measures the angle between vectors l2 : Euclidean distance - measures straight-line distance ip : Inner product - measures dot product similarity data_manager: distance_metric: cosine # Options: cosine, l2, ip","title":"Distance Metrics"},{"location":"user_guide/#embedding-models","text":"Embeddings convert text into numerical vectors. A2RCHI supports multiple embedding providers:","title":"Embedding Models"},{"location":"user_guide/#openai-embeddings","text":"data_manager: embedding_name: OpenAIEmbeddings embedding_class_map: OpenAIEmbeddings: class: OpenAIEmbeddings kwargs: model: text-embedding-3-small similarity_score_reference: 10","title":"OpenAI Embeddings"},{"location":"user_guide/#huggingface-embeddings","text":"data_manager: embedding_name: HuggingFaceEmbeddings embedding_class_map: HuggingFaceEmbeddings: class: HuggingFaceEmbeddings kwargs: model_name: sentence-transformers/all-MiniLM-L6-v2 model_kwargs: device: cpu encode_kwargs: normalize_embeddings: true similarity_score_reference: 10 query_embedding_instructions: null","title":"HuggingFace Embeddings"},{"location":"user_guide/#supported-document-formats","text":"The vector store can process the following file types: Text files : .txt , .C Markdown : .md Python : .py HTML : .html PDF : .pdf Documents are automatically loaded with the appropriate parser based on file extension.","title":"Supported Document Formats"},{"location":"user_guide/#document-synchronization","text":"A2RCHI automatically synchronizes your data directory with the vector store: Adding documents : New files in the data directory are automatically chunked, embedded, and added to the collection Removing documents : Files deleted from the data directory are removed from the collection Source tracking : Each ingested artifact is recorded in the unified index.yaml file as <resource-hash>: <relative file path> inside the data directory","title":"Document Synchronization"},{"location":"user_guide/#hybrid-search","text":"Combine semantic search with keyword-based BM25 search for improved retrieval: data_manager: use_hybrid_search: true bm25_weight: 0.6 semantic_weight: 0.4 bm25: k1: 0.5 b: 0.75 use_hybrid_search : Enable hybrid search combining BM25 and semantic similarity. Default: false bm25_weight : Weight for BM25 keyword scores. Default: 0.6 semantic_weight : Weight for semantic similarity scores. Default: 0.4 bm25.k1 : BM25 term frequency saturation parameter. Default: 0.5 bm25.b : BM25 document length normalization parameter. Default: 0.75","title":"Hybrid Search"},{"location":"user_guide/#stemming","text":"By specifying the stemming option within your configuration, stemming functionality for the documents in A2RCHI will be enabled. By doing so, documents inserted into the retrieval pipeline, as well as the query that is matched with them, will be stemmed and simplified for faster and more accurate lookup. data_manager: stemming: enabled: true When enabled, both documents and queries are processed using the Porter Stemmer algorithm to reduce words to their root forms (e.g., \"running\" \u2192 \"run\"), improving matching accuracy.","title":"Stemming"},{"location":"user_guide/#chromadb-backend","text":"A2RCHI supports both local and remote ChromaDB instances:","title":"ChromaDB Backend"},{"location":"user_guide/#local-persistent","text":"services: chromadb: local_vstore_path: /path/to/vectorstore","title":"Local (Persistent)"},{"location":"user_guide/#remote-http-client","text":"services: chromadb: use_HTTP_chromadb_client: true chromadb_host: localhost chromadb_port: 8000","title":"Remote (HTTP Client)"},{"location":"user_guide/#benchmarking","text":"","title":"Benchmarking"},{"location":"user_guide/#required-inputs-and-configuration","text":"A2RCHI has benchmarking functionality provided by the evaluate CLI command. Before beginning, provide your list of questions in JSON format as follows: [ { \"question\": \"\", \"link\": \"\", \"answer\": \"\" }, ... { \"question\": \"\", \"link\": \"\", \"answer\": \"\" } ] Then within all of the yaml configuration files that you wish to test, add a configuration for your benchmarking script, which looks like the following: services: benchmarking: queries_path: examples/benchmarking/queries.json out_dir: bench_out modes: - \"RAGAS\" - \"LINKS\" Finally, before you run the command ensure out_dir , the output directory, both exists on your system and that the path is correctly specified so that results can show up inside of it. To run the benchmarking script simply run the following:","title":"Required inputs and configuration"},{"location":"user_guide/#running_9","text":"a2rchi evaluate -n <name> -e <env_file> -cd <configs_directory> <optionally use -c <file1>,<file2>, ...> <OPTIONS> Currently, the benchmarking supports both a RAGAS runtime and a LINKS runtime, users can specify which modes they want to run by using the modes section. By default, both are enabled. The LINKS mode will generate outputs from your A2RCHI instance as specified in your other configurations and evaluate it based on if the top k documents retrieved include information from the provided link answer. Note however that this still might mean that the chunks provided as context might still be incorrect, even if they are from the same source link.","title":"Running"},{"location":"user_guide/#additional-options","text":"The RAGAS mode will use the Ragas RAG evaluator module to return numerical values judging by 4 of their provided metrics: answer_relevancy , faithfulness , context precision , and context relevancy . More information about these metrics can be found on their website at: https://docs.ragas.io/en/stable/concepts/metrics/. Note that ragas will by default use OpenAI to evaluate your llm responses and ragging pipeline contexts. To change this, it is possible to specify using other providers such as Anthropic, Ollama, and HuggingFace for your LLM evaluator, as well as HuggingFace for the embeddings. To do so simply specify in the configuration as follows: services: benchmarking: queries_path: examples/benchmarking/queries.json out_dir: bench_out modes: - \"RAGAS\" - \"LINKS\" mode_settings: ragas_settings: provider: <provider name> # can be one of OpenAI, HuggingFace, Ollama, and Anthropic evaluation_model_settings: model_name: <model name> # ensure this lines up with the langchain API name for your chosen model and provider base_url: <url> # address to your running Ollama server should you have chosen the Ollama provider embedding_model: <embedding provider> # OpenAI or HuggingFace You might also want to adjust the timeout setting, which is the upper limit on how long the Ragas evaluation takes on a single QA pair, or the batch_size , which determines how many QA pairs to evaluate at once, which you might want to adjust, e.g., based on hardware constraints, as Ragas doesn't pay great attention to that. The corresponding configuration options are similarly set for the benchmarking services, as follows: services: benchmarking: timeout: <time in seconds> # default is 180 batch_size: <desired batch size> # no default setting, set by Ragas... To later examine your data, there is a folder called plots in the base directory which contains some plotting functions and an ipynotebook with some basic usage examples. This is useful to play around with the results of the benchmarking, we will soon also have instead dedicated scripts to produce the plots of interest.","title":"Additional options"},{"location":"user_guide/#other","text":"Some useful additional features supported by the framework.","title":"Other"},{"location":"user_guide/#add-chromadb-document-management-api-endpoints","text":"","title":"Add ChromaDB Document Management API Endpoints"},{"location":"user_guide/#debugging-chromadb-endpoints","text":"Debugging REST API endpoints to the A2RCHI chat application for programmatic access to the ChromaDB vector database can be exposed with the following configuration change. To enable the ChromaDB endpoints, add the following to your config file under services.chat_app : services: chat_app: # ... other config options ... enable_debug_chroma_endpoints: true # Default: false","title":"Debugging ChromaDB endpoints"},{"location":"user_guide/#chromadb-endpoints-info","text":"","title":"ChromaDB Endpoints Info"},{"location":"user_guide/#apilist_docs-get","text":"Lists all documents indexed in ChromaDB with pagination support. Query Parameters: - page : Page number (1-based, default: 1) - per_page : Documents per page (default: 50, max: 500) - content_length : Content preview length (default: -1 for full content) Response: { \"pagination\": { \"page\": 1, \"per_page\": 50, \"total_documents\": 1250, \"total_pages\": 25, \"has_next\": true, \"has_prev\": false }, \"documents\": [...] }","title":"# /api/list_docs (GET)"},{"location":"user_guide/#apisearch_docs-post","text":"Performs semantic search on the document collection using vector similarity. Request Body: - query : Search query string (required) - n_results : Number of results (default: 5, max: 100) - content_length : Max content length (default: -1, max: 5000) - include_full_content : Include complete document content (default: false) Response: { \"query\": \"machine learning\", \"search_params\": {...}, \"documents\": [ { \"content\": \"Document content...\", \"content_length\": 1200, \"metadata\": {...}, \"similarity_score\": 0.85 } ] }","title":"# /api/search_docs (POST)"}]}